---
tags:
  - Java
---
# Java容器类



| **类/接口**                         | **描述**                                                                   | **特性**                                                | **相关信息/用途**                         |
| -------------------------------- | ------------------------------------------------------------------------ | ----------------------------------------------------- | ----------------------------------- |
| **AbstractCollection**           | `Collection` 接口的抽象实现，提供了大多数 `Collection` 接口的方法的基础实现。                     | - 作为自定义集合类的基础。<br> - 需要实现 `size()` 和 `iterator()` 方法。 | - 常用于简化自定义集合类的开发。                   |
| **AbstractList**                 | `List` 接口的抽象实现，继承自 `AbstractCollection`，提供了 `List` 的大部分功能。               | - 需要实现 `get(int index)` 和 `size()` 方法。                | - `ArrayList` 和 `LinkedList` 都继承自它。 |
| **AbstractQueue**                | `Queue` 接口的抽象实现，继承自 `AbstractCollection`，为队列的操作提供了基础实现。                  | - 提供 `offer()` 和 `poll()` 的默认实现。                      | - 用于队列的自定义实现。                       |
| **AbstractSequentialList**       | `List` 的抽象实现，适合使用顺序访问而不是随机访问的列表，例如链表。                                    | - 提供通过 `ListIterator` 顺序访问元素的支持。                      | - 常用于链表等非随机访问集合。                    |
| **AbstractSet**                  | `Set` 的抽象实现，继承自 `AbstractCollection`，提供了 `Set` 的基本功能。                    | - 提供 `equals()` 和 `hashCode()` 的基础实现，保证集合中元素的唯一性。     | - 常用于自定义无重复集合的实现。                   |
| **ArrayBlockingQueue**           | 基于数组的有界阻塞队列，使用锁机制实现线程安全。                                                 | - 固定大小的有界队列。<br> - 适合生产者-消费者模型。                       | - 常用于需要限制队列长度的并发场景。                 |
| **==ArrayDeque==**               | 基于数组的双端队列，提供栈和队列的双重功能。                                                   | - 支持双端插入和删除操作。<br> - 动态扩容。                            | - 用于双端操作或栈的替代。                      |
| **==ArrayList==**                | 动态数组实现的 `List`，支持随机访问和动态扩容。                                              | - 动态扩展容量。<br> - 支持随机访问。                               | - 适合需要频繁读取和按索引访问的场景。                |
| **AttributeList**                | `List` 接口的实现，用于管理 `javax.management` 包中的 MBean 属性列表。                     | - 线程安全。                                               | - 用于 MBean 属性的读取和管理。                |
| **BeanContextServicesSupport**   | `BeanContextServices` 的默认实现，提供服务查找和注册的支持。                                | - 支持服务注册和管理。<br> - 允许多个 JavaBeans 组件共享服务。             | - 用于 JavaBeans 服务注册与管理。             |
| **BeanContextSupport**           | `BeanContext` 的默认实现，提供对 JavaBeans 容器的支持。                                 | - 提供基础的 JavaBeans 组件管理。<br> - 支持事件传播。                 | - 用于 JavaBeans 容器管理。                |
| **ConcurrentHashMap.KeySetView** | `ConcurrentHashMap` 提供的线程安全的 `Set` 视图，允许对 `ConcurrentHashMap` 中的键进行视图操作。 | - 线程安全。<br> - 提供对 `ConcurrentHashMap` 键的只读或操作性视图。     | - 用于高并发环境中键集合的操作。                   |
| **ConcurrentLinkedDeque**        | 线程安全的双端无界非阻塞队列。                                                          | - 无界队列，基于链表。<br> - 非阻塞算法实现。                           | - 常用于高并发场景中的双端队列。                   |
| **ConcurrentLinkedQueue**        | 线程安全的无界非阻塞队列，基于链表实现。                                                     | - 无界队列。<br> - 高效的非阻塞算法。                               | - 适合高并发场景中的队列操作。                    |
| **ConcurrentSkipListSet**        | 线程安全的有序 `Set`，基于跳表实现，元素按自然顺序或比较器排序。                                      | - 有序集合。<br> - 高效的并发访问和修改。                             | - 用于需要有序集合和高并发支持的场景。                |
| **CopyOnWriteArrayList**         | 线程安全的 `List` 实现，所有修改操作都会复制数组，因此适合读多写少的场景。                                | - 读操作不加锁。<br> - 写操作会复制数组。                             | - 适合读多写少的场景，如事件监听器列表。               |
| **CopyOnWriteArraySet**          | 线程安全的 `Set` 实现，所有修改操作都会复制集合。                                             | - 类似 `CopyOnWriteArrayList`，但用于 `Set`。                | - 适合读多写少的无重复元素集合。                   |
| **DelayQueue**                   | 支持延迟元素的阻塞队列，元素只有在延迟到期后才能被取出。                                             | - 元素按延迟时间排序。<br> - 用于需要延迟执行任务的场景。                     | - 适合任务调度场景。                         |
| **EnumSet**                      | 高效的 `Set` 实现，用于枚举类型。                                                     | - 元素只能是枚举类型。<br> - 内部使用位向量实现，性能高效。                    | - 适合管理枚举常量集合。                       |
| **==HashSet==**                  | 基于哈希表的无序 `Set` 实现，支持快速查找、插入和删除。                                          | - 无序。<br> - 不允许重复元素。                                  | - 常用于需要快速操作且不关心顺序的场景。               |
| **JobStateReasons**              | `JobStateReasons` 类是用于记录和管理打印任务状态及原因的集合。                                 | - 记录打印任务状态。                                           | - 用于打印系统中的任务状态管理。                   |
| **LinkedBlockingDeque**          | 基于链表的有界阻塞双端队列，支持双端插入和删除，适合并发环境。                                          | - 支持双端操作。<br> - 阻塞操作，线程安全。                            | - 用于需要双端操作的多线程任务队列。                 |
| **LinkedBlockingQueue**          | 基于链表的有界阻塞队列，支持单端操作，适合生产者-消费者模型。                                          | - 阻塞操作，线程安全。                                          | - 常用于并发环境下的任务调度和数据传输。               |
| **==LinkedHashSet==**            | 保留元素插入顺序的 `HashSet`，基于链表实现，支持有序访问。                                       | - 按插入顺序保留元素。<br> - 不允许重复元素。                           | - 适合需要有序且无重复元素的场景。                  |
| **==LinkedList==**               | 双向链表实现的 `List` 和 `Deque`，支持双端插入和删除。                                      | - 支持 `List` 和 `Deque` 的操作。<br> - 双向链表，适合频繁的插入和删除操作。   | - 常用于需要频繁插入和删除的场景。                  |
| **LinkedTransferQueue**          | 基于链表的无界阻塞队列，允许生产者等待消费者处理消息。                                              | - 支持直接消息传递。<br> - 线程安全，适合高并发场景。                       | - 适用于生产者-消费者模型中的任务调度。               |
| **PriorityBlockingQueue**        | 支持元素优先级排序的阻塞队列，基于堆实现。                                                    | - 队列中的元素按优先级排序。<br> - 支持阻塞操作。                         | - 用于优先级任务调度。                        |
| **==PriorityQueue==**            | 支持元素优先级排序的非阻塞队列，基于堆实现。                                                   | - 无界队列。<br> - 元素按优先级排序。                               | - 用于非阻塞优先级任务调度。                     |
| **RoleList**                     | 继承自 `ArrayList`，专门用于保存 `Role` 对象的列表。                                     | - 线程安全。                                               | - 用于 Java 安全模型中的角色管理。               |
| **RoleUnresolvedList**           | 继承自 `ArrayList`，用于保存未解决的 `Role` 对象的列表。                                   | - 线程安全。                                               | - 用于处理未解决角色的问题。                     |
| **==Stack==**                    | 基于 `Vector` 实现的栈，支持 LIFO 操作。                                             | - 线程安全。<br> - 扩展了 `Vector` 的功能。                       | - 用于传统的 LIFO 堆栈操作场景。                |
| **SynchronousQueue**             | 阻塞队列，每次插入操作必须等待相应的取出操作，反之亦然。                                             | - 无缓冲的阻塞队列。<br> - 用于严格的生产者-消费者模型。                     | - 适合任务直接交接的场景。                      |
| **==TreeSet==**                  | 基于 `TreeMap` 的有序 `Set` 实现，元素按自然顺序或自定义比较器排序。                              | - 元素有序。<br> - 不允许重复元素。                                | - 用于需要保持有序无重复集合的场景。                 |
| **==Vector==**                   | 线程安全的动态数组实现，类似于 `ArrayList`。                                             | - 线程安全。<br> - 动态扩容。                                   | - 适合需要线程安全的动态数组场景。                  |

