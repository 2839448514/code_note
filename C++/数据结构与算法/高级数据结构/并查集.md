## 并查集

并查集（Disjoint Set）是一种数据结构，用于处理集合的合并与查询问题。它提供了两个主要的操作：

1. `Find`：查找元素所属的集合，通常用于判断两个元素是否属于同一个集合，即判断它们的根节点是否相同。
2. `Union`：将两个集合合并成一个集合，通常将一个集合的根节点连接到另一个集合的根节点上。

并查集通常用一个数组来表示集合，其中数组的每个元素代表一个节点，数组的索引代表节点的标识，数组中的值代表节点的父节点（或者是指向根节点的指针）。通过这种方式，我们可以快速地找到节点所在的集合，并在需要时进行集合的合并操作。

以下是并查集的一些常见应用：

1. **图的连通性问题**：并查集可以用来判断图中的两个顶点是否连通，即是否存在一条路径连接它们。通过对图的边进行合并操作，我们可以将连通的顶点合并到同一个集合中，并且可以快速地判断两个顶点是否在同一个集合中，从而实现图的连通性问题。
2. **最小生成树算法（如 Kruskal 算法）**：在求解最小生成树的过程中，需要判断边的两个端点是否在同一个连通分量中，如果不在，则可以将这条边加入最小生成树中，并将两个端点合并到同一个连通分量中。
3. **网络连接状态的判断**：在网络中，我们经常需要判断两台计算机之间是否存在连接。通过并查集，我们可以维护网络中各个计算机的连接状态，并快速地判断两台计算机是否连接在同一个网络中。
4. **岛屿数量问题**：在二维网格中，有时需要统计岛屿的数量。通过并查集，我们可以将相邻的陆地连接到同一个集合中，并统计集合的数量即可得到岛屿的数量。

```c++
#include <iostream>
using namespace std;
int s[100];
void init_set(){
    for(int i=0;i<100;i++){
        s[i]=i;
    }
}
int Find_set(int x) {
    return x == s[x] ? x : s[x] = Find_set(s[x]);
}
void Union_set(int x,int y){
    x= Find_set(x),y= Find_set(y);
    if(x!=y){
        s[x]=s[y];
    }
}
int main() {

}
```

## 带权并查集

```c++
int Find_set(int x) {
    if (x != s[x]) {
        int t = s[x];
        s[x] = find_set(s[x]);
        d[x] += d[t];
    }
}
```

