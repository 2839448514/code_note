## 专业术语

- **[[内建]]**

---



---

## 值类别

每个 C++ 表达式（带有操作数的操作符、字面量、变量名等）可按照两种独立的特性加以辨别：**类型**和**值类别** (value category)。每个表达式都具有某种非引用类型，且每个表达式只属于三种基本值类别中的一种：**纯右值 (prvalue)**、**亡值 (xvalue)**、**左值 (lvalue)**。

C++17进一步细化了值类别的定义，使得表达式的分类更加精确和全面。例如，C++17中引入了`decltype`关键字，**用于获取和推断对象和表达式的类型，并且在类型推导上涉及到对表达式值类别的区分。**

1. **左值（lvalue）**：
    - 左值（lvalue）是指可以出现在赋值操作符左侧的表达式，通常表示一个对象或函数，它代表一个特定的内存位置（地址）。
    - 左值可以被取地址（即使用`&`操作符），通常是可以被修改的（除非是 `const` 左值）。
    - 左值可以进一步细分为泛左值（glvalue），泛左值包括左值和亡值（xvalue）。
2. **纯右值（prvalue）**：
    - 纯右值（prvalue）是指计算结果不关联特定存储位置的表达式，通常表示一个临时对象或立即值（如字面量）。
    - 纯右值不能被取地址（因为它没有确定的内存地址），且不能被直接修改。
    - 纯右值用于构造对象、初始化或计算值。
3. **亡值（xvalue）**：
    - 亡值（xvalue）是指表达式表示即将被销毁的对象，通常在移动语义中出现，如 `std::move` 的结果。亡值可以被认为是“将亡的左值”。
    - 亡值可以被取地址，但不能用于修改原值。
    - 亡值属于泛左值（glvalue），因为它指向某个对象（或资源），但它的资源可以被“窃取”用于其他用途。
4. **泛左值（glvalue）**：
    - 泛左值（glvalue）是左值（lvalue）和亡值（xvalue）的统称，表示一个对象或函数的存储位置（地址）。
    - 泛左值可以被取地址，并表示一个具体的对象或函数。
5. **右值（rvalue）**：
    - 右值（rvalue）是纯右值（prvalue）和亡值（xvalue）的统称，通常表示临时对象或计算结果。
    - 右值不能出现在赋值号左侧（赋值操作符需要一个左值），通常不可被取地址（除了亡值可以被取地址）。

**C++11标准库提供了`std::move()`函数，可以将左值转换为右值引用。这使得开发者可以在需要时显式地触发移动操作，从而优化性能。**

#### C++17中`decltype`关键字如何影响值类别的处理和类型推导？

在C++17中，`decltype`关键字对值类别的处理和类型推导有显著影响。首先，**`decltype`用于获取表达式的类型，但不会求值该表达式**。这意味着它能够保留变量或表达式的原有类型，包括引用和`const`属性。例如，如果`decltype`用于一个变量，它会返回该变量的类型，包括顶层的`const`和引用。

`decltype`与`auto`关键字类似，但它们的使用场景有所不同。**`auto`根据初始化表达式的值来推导变量的类型，而`decltype`则根据表达式本身来推导类型**。这使得`decltype`在某些情况下更为灵活，尤其是在处理函数返回类型或类成员变量类型时。

特别地，`decltype(auto)`语法在C++17中被引入，用于简化函数返回值类型的推导。通过这种语法，函数的返回值类型可以通过函数体内的返回表达式来推导，从而避免了显式指定返回类型的需要。

此外，`decltype`还能够处理未定义的`id-expression`或类成员访问，返回该实体的类型。对于`xvalue`和`lvalue`，`decltype(e)`分别返回T&&和T&的类型

## 基本类别

### 左值

#### **左值表达式**：

- **变量、函数、模板形参对象(C++20 起)或数据成员之名**，不论其类型，例如 `std::cin`或 `std::end`。即使变量的类型是右值引用，由其名字构成的表达式仍**是左值表达式**；
- **返回类型为左值引用的函数调用或重载运算符表达式**，例如 `std::getline(std::cin, str)`、`std::cout << 1`、`str1 = str2` 或 `++it`；
- `a = b`，`a += b`，`a %= b`，以及所有其他**内建的赋值及复合赋值表达式**；
- `++a` 和 `--a`，**内建的前置自增与前置自减表达式**；
- `*p`，**内建的间接寻址表达式**；
- `a[n]` 和 `n[a]`，**内建的下标表达式**，但 `a[n]` 中的一个操作数应为数组左值 (C++11 起)；
- `a.m`，**对象成员表达式**，除了 `m` 为成员枚举项或非静态成员函数，或者 `a` 为右值而 `m` 为非引用类型的非静态数据成员的情况；
- `p->m`，**内建的指针成员表达式**，除了 `m` 为成员枚举项或非静态成员函数的情况；
- `a.*mp`，**对象的成员指针表达式**，其中 `a` 是左值且 `mp` 是数据成员指针；
- `p->*mp`，**内建的指针的成员指针表达式**，其中 `mp` 是数据成员指针；
- `a, b`，**内建的逗号表达式**，其中 `b` 是左值；
- `a ? b : c`，对某些 `b` 和 `c` 的三元条件表达式（例如，当它们都是同类型左值时，但细节见其定义）；
- **字符串字面量**，例如 `"Hello, world!"`；
- **转换为左值引用类型的转型表达式**，例如 `static_cast<int&>(x)`；
- **返回类型是到函数的右值引用的函数调用表达式或重载的运算符表达式；**(C++11 起)
- **转换为函数的右值引用类型的转型表达式**，如 `static_cast<void (&&)(int)>(x)`。(C++11 起)

#### **性质：**

- 与泛左值相同（见下文）。
- **可以由内建的取址运算符取左值的地址**：`&++i`及 `&std::endl` 是合法表达式。
可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数。
- **左值可用于初始化左值引用**；这会将一个新名字关联给该表达式所标识的对象。

### 纯右值

#### 纯右值表达式_：

- （除了字符串字面量之外的）**字面量**，例如 `42`、`true` 或 `nullptr`；
- **返回类型是非引用的函数调用或重载运算符表达式**，例如 `str.substr(1, 2)`、`str1 + str2` 或 `it++`；
- `a++` 和 `a--`，**内建的后置自增与后置自减表达式**；
- `a + b`、`a % b`、`a & b`、`a << b`，以及其他**所有内建的算术表达式**；
- `a && b`、`a || b`、`!a`，**内建的逻辑表达式**；
- `a < b`、`a == b`、`a >= b` 以及其他**所有内建的比较表达式**；
- `&a`，**内建的取地址表达式**；
- `a.m`，**对象成员表达式**，**其中 `m` 是成员枚举项或非静态成员函数**，或其中 `a` 为右值且 `m` 为非引用类型的非静态数据成员 (C++11 前)；
- `p->m`，**内建的指针成员表达式**，其中 `m` 为成员枚举项或非静态成员函数；
- `a.*mp`，**对象的成员指针表达式**，其中 `mp` 是成员函数指针，或其中 `a` 为右值且 `mp` 为数据成员指针 (C++11 前)；
- `p->*mp`，内建的指针的成员指针表达式，其中 `mp` 是成员函数指针；
- `a, b`，内建的逗号表达式，其中 `b` 是右值；
- `a ? b : c`，对某些 `b` 和 `c` 的**三元条件表达式**（细节见其定义）；
- **转换为非引用类型的转型表达式**，例如 `static_cast<double>(x)`、`std::string{}` 或 `(int)42`；
- `this` 指针；
- **枚举项**;
- **非类型模板形参**，除非其类型为类或 (C++20 起)左值引用类型；
- **`lambda` 表达式**，例如` [](int x){ return x * x; }`； (C++11 起) 
- **`requires` 表达式**，例如` requires (T i) { typename T::type; }`；
- **概念的特化**，例如 `std::equality_comparable<int>`。 (C++20 起) 

#### 性质：

- 与右值相同（见下文）。
- **纯右值不能多态**：它所标识的对象的动态类型始终为该表达式的类型。
- **非类非数组的纯右值不能有 `cv` 限定**。（注意：函数调用或转型表达式可能生成非类的 cv 限定类型的纯右值，但其 cv 限定符被立即剥除。）
- **纯右值不能具有不完整类型**（除了类型 void（见下文），或在 decltype 说明符中使用之外）
- **纯右值不能具有抽象类类型或其数组类型**。

#### 亡值

#### 亡值表达式_：

- **返回类型为对象的右值引用的函数调用或重载运算符表达式**，例如 `std::move(x)`；
- `a[n]`，**内建的下标表达式**，其操作数之一是数组右值；
- `a.m`，**对象成员表达式**，其中 `a` 是右值且 `m` 是非引用类型的非静态数据成员；
- `a.*mp`，**对象的成员指针表达式**，其中 `a` 为右值且 `mp` 为数据成员指针；
- `a ? b : c`，**对某些 `b` 和 `c` 的三元条件表达式**（细节见其定义）；
- **转换为对象的右值引用类型的转型表达式**，例如 `static_cast<char&&>(x)`；
- 在临时量实质化后，任何指代临时对象的表达式。 (C++17 起) 

#### 性质：

- 与右值相同（见下文）。
- 与泛左值相同（见下文）。
- **特别是，与所有的右值类似，亡值可以绑定到右值引用上，而且与所有的泛左值类似，亡值可以是多态的，而且非类的亡值可以有 [[cv（const 与 volatile）类型限定符]]。**

## 在C++中，亡值（xvalue）的具体应用场景和示例是什么？

在C++中，**将亡值（xvalue）是C++11标准引入的一个概念，用于描述那些即将被销毁但仍然可以被移动的值**。**将亡值通常与右值引用相关联**，其主要应用场景包括：

1. **返回右值引用的函数**：**当一个函数返回一个右值引用时，返回的临时对象即为将亡值**。例如：

```c++
std::vector<int>&& foo() {
	std::vector<int> temp = {1, 2, 3, 4};       
	return std::move(temp); // 返回的temp是一个将亡值    
}
```

在这个例子中，`foo()`返回的是一个右值引用，因此返回的临时`temp`是一个将亡值。

2. **使用`std::move`函数**：**`std::move`函数会将一个左值转换为右值引用，从而产生将亡值**。例如：

```c++
   int a = 10;    
   auto b = std::move(a); // b是一个将亡值
```

在这里，`std::move(a)`将左值`a`转换为右值引用，因此`b`是一个将亡值。

3. **右值类对象的成员**：**如果一个类的对象是右值引用类型，则该对象的成员也是将亡值**。例如：

```c++
   class MyClass {    
   public:        
	   MyClass&& get() { 
	   return std::move(*this); 
	   }    
   };    
   MyClass obj;    
   auto x = obj.get (); // x是一个将亡值
```

在这个例子中，`obj.get ()`返回的是一个右值引用，因此`x`是一个将亡值。

4. **右值数组的成员**：类似地，**右值数组的成员也是将亡值**。例如：

```C++
   int arr[] = {1, 2, 3};    
   auto& ref = arr[0]; // ref是一个将亡值
```

## 混合类别

### 泛左值

**_泛左值_表达式包括左值、亡值。**

#### 性质：

- **泛左值可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值。**
- **泛左值可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型。**
- **泛左值可以具有不完整类型，只要表达式中容许。**

### 右值

**_右值表达式_包括纯右值、亡值。**

#### 性质：

- **右值不能由内建的取址运算符取地址：`&int()`、`&i++3`、`&42` 及 `&std::move(x) `是非法的。**
- **右值不能用作内建赋值运算符及内建复合赋值运算符的左操作数。**
- **右值可以用于初始化 `const` 左值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。**
- **右值可以用于初始化右值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。(C++11 起)**
- **当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上（从而，当复制与移动构造函数均可用时，以右值实参将调用其移动构造函数，复制和移动赋值运算符与此类似）。(C++11 起)**

#### C++中泛左值（glvalue）与纯右值（prvalue）在实际编程中的区别和联系是什么？

### 泛左值（glvalue）

**泛左值是“泛化左值”的缩写，它是一个表达式**，**其值可以确定某个对象、位域或函数的标识**。泛左值可以进一步分为传统意义上的左值（lvalue）和将亡值（xvalue）。**传统左值通常是指那些具有持久存储位置的变量或对象，而将亡值则是通过右值引用产生的临时对象。**

### 纯右值（prvalue）

**纯右值是“纯右值”的缩写，它是一个表达式**，**其值用于初始化某个对象或位域，但本身没有结果对象**。**纯右值通常与临时变量或字面量相关联**，例如运算符操作数的计算结果。纯右值不具名且可被移动，这意味着它们可以在需要时被移动到其他位置而不影响原始数据。

### 区别和联系

1. **用途**：
    
    - 泛左值主要用于访问和操作已存在的对象或函数。
    - 纯右值主要用于初始化新的对象或位域，或者作为临时变量使用。
2. **生命周期**：
    
    - 泛左值通常对应于持久的对象或变量，具有较长的生命周期。
    - 纯右值通常是临时的，生命周期较短，通常只存在于当前语句中。
3. **可移动性**：
    
    - 泛左值不可移动，因为它们代表的是持久的对象。
    - 纯右值可以移动，因为它们通常是临时的，不需要保留原始数据。
4. **地址取用**：
    
    - 泛左值可以取地址，因为它们代表的是具有持久存储位置的对象。
    - 纯右值不能直接取地址，但可以通过生成临时变量来间接取地址。

### 实际编程中的应用

- **泛左值**：常用于赋值、引用、解引用等操作。例如：

```c++
  int a = 5; // a 是一个泛左值   
  int& ref = a; // ref 是对 a 的引用

```

- **纯右值**：常用于初始化新的对象或位域，或者作为函数返回值。例如：

```c++
  int b = 10; // b 是一个泛左值   
  int c = int(10);  
```

## C++性能优化中，如何通过理解值类别来避免不必要的拷贝操作？  

- 在C++性能优化中，理解值类别（value categories）对于避免不必要的拷贝操作至关重要。值类别是C++中用于描述表达式如何参与操作的一种分类方法，**主要包括左值（lvalue）、右值（rvalue）、常量表达式（constant expression）等**。通过合理利用这些类别，可以显著减少不必要的拷贝操作，从而提高程序的性能。     
- **返回值优化（Return Value Optimization, RVO）是一种编译器优化技术，旨在避免在函数返回时进行不必要的拷贝操作**。具体来说，RVO通过将返回值的存储位置直接设置为调用者的变量位置来实现，从而避免了临时对象的拷贝。例如，具名返回值优化（Named Return Value Optimization, NRVO）和无名返回值优化（Copy Elision）都是RVO的具体实现形式。     
- **右值引用允许将一个对象的值移动到另一个对象中，而无需复制或销毁原始对象**。这解决了传统C++中的“移动”和“拷贝”概念混淆的问题。通过使用右值引用，可以避免不必要的内存拷贝和资源管理，从而提高程序的性能和效率。例如，当一个临时对象被传递给一个接受右值引用的函数时，编译器会自动使用移动语义而不是拷贝语义。     
- **使用std::sharedptr可以避免不必要的拷贝操作**。由于std::sharedptr的引用计数机制，当一个std::shared_ptr被复制时，实际上只是增加了引用计数，而不会真正复制对象本身。因此，这可以显著减少不必要的拷贝操作。     
- **在C++/CLI语言规范中，值类被设计为高效快速地复制数据，而无需使用内存间接访问**。值类实例可以被包装，并且其成员默认是私有的，从而减少了对垃圾回收器的影响。     
- **临时对象是指在函数执行期间不会被保留的变量或数据**。通过使用右值引用，可以避免对临时对象的访问，从而减少不必要的复制操作并提高性能。

---

相关事件

| 事件名称                       | 事件时间              | 事件概述                                                  |
| -------------------------- | ----------------- | ----------------------------------------------------- |
| C++11引入值类别概念               | 不详                | 技术更新C++11通过引入了右值引用、纯右值和亡值三个细类，对表达式的值类别进行了分类。          |
| C++98的分类法                  | 不详                | 技术历史C++98采用的是左值和右值的分类法。                               |
| C++17对值类别的重新表述             | 不详                | 技术更新在C++17中，值类别的特征被重新表述，明确了glvalue和prvalue的概念。        |
| C++11引入decltype关键字和auto关键字 | 不详，但提及自C++11开始使用  | 技术更新C++11引入了`decltype`关键字和`auto`关键字，用于获取和推断对象和表达式的类型。 |
| C++模板推导与值类别的关系             | 2023年02月07日       | 技术说明C++中的表达式属性包括值类型和值类别，每个表达式都属于三类之一。                 |
| C++移动语义的引入                 | 不详，但提及自C++11引入后变化 | 技术更新C++11引入的值类别概念增强了语言的效率和性能，特别是通过移动语义的概念。            |

### 特殊类别

#### 未决成员函数调用

表达式 `a.mf` 与 `p->mf`，其中 `mf` 是非静态成员函数，以及表达式 `a.*pmf` 与 `p->*pmf`，其中 `pmf` 是成员函数指针，被归类为纯右值表达式，但它们不能用来初始化引用，作为函数实参，或者用于除了作为函数调用运算符的左操作数（例如 `(p->*pmf)(args)`）以外的任何目的。

#### void 表达式

返回 `void` 的函数调用表达式，转换为 `void` 的转型表达式，以及` throw` 表达式，被归类为纯右值表达式，但它们不能用来初始化引用或者作为函数实参。它们可以用在舍弃值的语境（例如自成一行，作为逗号运算符的左操作数等）和返回 `void` 的函数中的 `return` 语句中。另外，`throw` 表达式可用作条件运算符` ?: `的第二个和第三个操作数。

#### 位域

代表某个位域的表达式（例如 `a.m`，其中 `a` 是类型 `struct A { int m: 3; }` 的左值）是泛左值表达式：它可用作赋值运算符的左操作数，但它不能被取地址，并且非 const 的左值引用不能绑定于它。`const `左值引用或右值引用可以从位域泛左值初始化，但这会制造位域的一个临时副本：它不会直接绑定到位域。

---
---
---

## 来源

1. [C++ 值类别 - 简书](https://www.jianshu.com/p/6845112bb4ff)

2. [C++概念：值类别(左值、右值)、引用](https://juejin.cn/post/6860648369695260680) [2020-08-13]

3. [C++中的值类别与模板推导](https://www.cnblogs.com/riasartemis/p/17099475.html) [2023-02-07]

4. [C++ 值类别(value category)循序渐进（一）值类别是什么原创](https://blog.csdn.net/wxj1992/article/details/126734243) [2022-09-19]

5. [《C++ Templates》(2nd)附录B：Value Categories(值类别)](https://zhuanlan.zhihu.com/p/122398281)

6. [3.4 值类别 | Modern C++ Primer - GitHub Pages](https://dynilath.github.io/modern-cpp-primer/zh/03-types/value-category.html) [2024-07-26]

7. [C++11的value category（值类别）以及move semantics（移动语义） - 赵宗晟 - 博客园](https://www.cnblogs.com/zhao-zongsheng/p/value_categories_and_move_semantics.html)

8. [C++ 值类别定义与区分（左值、纯右值、亡值）、std::move 函数 - 简书](https://www.jianshu.com/p/27d3a64c418a)

9. [C++17 的值类别](https://weakyon.com/2022/10/31/value-category-of-cpp17.html) [2022-10-31]

10. [深入理解c++值类别体系 - Csdn博客](https://blog.csdn.net/LeoLei8060/article/details/138913553) [2024-05-15]

11. [C++ 的值类别、auto与decltype - CSDN博客](https://blog.csdn.net/imoisture/article/details/142438995) [2024-09-22]

12. [C++：值类别和 decltype 的祛魅 - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/593957444) [2022-12-24]

13. [C++11 中的左值、右值和将亡值 - 简书](https://www.jianshu.com/p/4538483a1d8a)

14. [c++中值类型数组和引用数组的区别原创](https://blog.csdn.net/u011555996/article/details/128474566) [2022-12-28]

15. [PDFUnderstanding C++ Value Categories. Krivan Rens.](http://becpp.org/blog/wp-content/uploads/2021/07/Kris-van-Rens-Understanding-Value-Categories.pdf)

16. [PDF工作草稿，标准化编程指南. Richard Smith等](https://isocpp.org/files/papers/n4582.pdf). [2016-03-19]

17. [PDFDemystifying Value Categories in C++. Nisi Meinert](https://indico.cern.ch/event/853710/contributions/3708821/attachments/1979863/3296506/slides.pdf). 

18. [PDFProfessional Notes for Educational Purposes. Goalkicker.com.](https://book.huihoo.com/goalkicker.com/CSharpBook/CSharpNotesForProfessionals.pdf)

19. [PDFECLA-3721st Edition/December 2005. ECMA International Rhéde](https://ecs.syr.edu/faculty/fawcett/handouts/CSE681/Presentations/CppCLI-ECMA-372.pdf). [2005-12-01]

20. [PDFECLA-3721stEdition/December 2005. ECMA International等](https://www.ecma-international.org/wp-content/uploads/ECMA-372_1st_edition_december_2005.pdf). [2005-12-01]

21. [PDF工作草稿：C++语言编程指南. Thomas Köppe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4964.pdf). [2023-10-14]

22. [PDF工作草稿，标准化项目管理. Stefan Du Toit等](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf). [2012-02-28]

23. [值类型和引用类型 - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/248799074)

24. [PDF工作草稿，标准化程序，项目规划. Richard Smith等](https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-12-05-cpp-memory-model/n4820.pdf). [2019-06-17]

25. [值类型和引用类型由来及详解(C++/C#混讲) - ShawBlack - 博客园](https://www.cnblogs.com/ShawBlack/p/16997772.html) [2022-12-22]

30. [C++17：decltype类型推导原创](https://blog.csdn.net/liuguang841118/article/details/130782888) [2023-06-17]

31. [C++ decltype 类型推导](https://www.cnblogs.com/linrj/p/16667708.html) [2022-09-07]

32. [C++ decltype类型推导完全攻略 - C语言中文网](https://c.biancheng.net/view/7151.html)

33. [C++ decltype 类型推导 - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/562354833)

34. [C++ 中复杂却很有意思的SFINAE技术 - luozhiyun`s Blog](https://www.luozhiyun.com/archives/744) [2023-01-21]

35. PDFDectype在变量和表达式中的类型推导

36. [第一节 类型推导—decltype - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/354287022)

37. [PDF工作草稿，标准化程序文件. Richard Smith等](https://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/n4659.pdf). [2017-03-21]

38. [PDF计算机程序设计基础. 计算机学院 黄章进](http://staff.ustc.edu.cn/~zhuang/cpp/lectures/CP5e02.pdf).

39. [PDF现代C++教程：高速上手C++ 11/14/17/20. 欧长坤](https://changkun.de/modern-cpp/pdf/modern-cpp-tutorial-zh-cn.pdf). [2024-06-01]

47. [左值和右值- 钟齐峰](https://www.cnblogs.com/zhongqifeng/p/16203815.html) [2022-05-01]

48. [C++ 浅谈之左值、纯右值、将亡值 - Csdn博客](https://blog.csdn.net/qq_44868502/article/details/128860977) [2023-02-03]

49. [C++标准库功能:Xvalue,prvalue和Lvalue 原创](https://blog.csdn.net/github_38148039/article/details/104138763) [2020-02-01]

50. [还分不清左值，右值，将亡值？看这里! - 腾讯云](https://cloud.tencent.com/developer/article/1543336)

51. [modern c++, understanding of xvalue - Stack Overflow](https://stackoverflow.com/questions/50662391/modern-c-understanding-of-xvalue)

52. [C++右值引用，左值(lvalue)、将亡值(xvalue)](https://blog.csdn.net/qq_40586164/article/details/107690601) [2020-07-30]

53. [C++的那些事——左值、纯右值和将亡值 - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/589182834)

54. [【重学C++】【引用】深入理解：右值引用(将亡值) 与 移动语义std::move_深入理解右值引用-CSDN博客](https://blog.csdn.net/Attitude93/article/details/137884024) [2024-04-26]

55. [c++ - Real life examples of xvalues, glvalues, and prvalues? - Stack ...](https://stackoverflow.com/questions/6609968/real-life-examples-of-xvalues-glvalues-and-prvalues)

56. [PDF现代C++教程：高速上手C++ 11/14/17/2023年5月7日更新. 欧长坤](https://changkun.de/modern-cpp/pdf/modern-cpp-tutorial-zh-cn.pdf). [2023-05-07]

61. [C++ lvalue，prvalue，xvalue，glvalue和rvalue详解（from cppreference）](https://www.cnblogs.com/Philip-Tell-Truth/p/6370019.html)

66. [如何评价 C++17 之后的 Value Categories (值类别)？ - 知乎](https://www.zhihu.com/question/382696217)

74. [C++高级编程（3）-- 移动语义与资源管理 - Csdn博客](https://blog.csdn.net/m0_51768024/article/details/136636711) [2024-03-11]

75. [C++ 移动语义 - 一亩三分地](https://mengbaoliang.cn/archives/23342/)

76. [C++移动语义：提升性能和资源管理的新境界](https://blog.csdn.net/m0_69824302/article/details/135953550) [2024-01-31]

77. [深入理解C++的移动语义](https://developer.baidu.com/article/details/3130725) [2024-02-18]

78. [C++移动语义：提升性能和资源管理的新境界 | w3cschool笔记](https://www.w3cschool.cn/article/37082527.html) [2024-01-31]

79. [利用移动语义优化 C++ 程序性能的实用指南 - Csdn博客](https://blog.csdn.net/windowshht/article/details/141526172)

80. [c++11如何理解移动语义和完美转发](https://juejin.cn/post/7253319695926558757) [2023-07-08]

81. [C++ move semantics 原创](https://blog.csdn.net/keineahnung2345/article/details/104074631) [2020-01-23]

82. [C++ std::move以及右值引用全面解析：从基础到实战，掌握现代C++高效编程-阿里云开发者社区](https://developer.aliyun.com/article/1463232) [2024-03-19]

83. [Nicolai M. Josuttis: C++ Move Semantics - The Complete Guide](http://cppmove.com/)

105. [深入c++之左值与右值原创](https://blog.csdn.net/kxlalala/article/details/122327788)

106. [Cpp / 右值、纯右值、将亡值 - CSDN博客](https://blog.csdn.net/itworld123/article/details/115470227)

107. [c++中的左值跟右值怎么区分？ - 知乎](https://www.zhihu.com/question/23520802)

108. [表达式 - 值类别 - 《C++ 语言构造参考手册》 - 书栈网 · BookStack](https://www.bookstack.cn/read/cppreference-language/a50079feea7594f9.md)

109. [C++左值和右值 - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/526034602)

110. [C++临时变量的生命周期，纯右值实体化 - 知乎 - 知乎专栏](https://zhuanlan.zhihu.com/p/419226658)

111. [广义左值-glvalue、左值-lvalue、右值-rvalue、纯右值-prvalue、将亡值-xvalue](https://zhuanlan.zhihu.com/p/634413850)

112. [值类别 - cppreference.com](http://cpp.7fa4.cn/zh/cpp/language/value_category.html)

113. [C++的右值引用、移动和值类别系统，你所需要的一切](https://zclll.com/index.php/cpp/value_category.html) [2022-04-04]

125. [C++17之省略不必要的拷贝Copy Elision 原创](https://blog.csdn.net/janeqi1987/article/details/100146445) [2019-08-30]

126. [Linux C++性能优化：从根本上消除拷贝操作的浪费](https://juejin.cn/post/7295381524316930063) [2023-10-30]

127. [C/C++性能优化：从根本上消除拷贝操作的浪费-阿里云开发者社区](https://developer.aliyun.com/article/1468653) [2024-03-26]

128. [C++ 拷贝控制 (五)：阻止拷贝 - Csdn博客](https://blog.csdn.net/qq_28256407/article/details/125204467)

129. [阻止拷贝的三种方式 - Csdn博客](https://blog.csdn.net/u012677715/article/details/77967774)
