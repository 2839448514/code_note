# 图像基本操作

## 1. 图像颜色空间

### 1.1 颜色模型转换

#### 1.1.1 cvtColor (图像颜色空间转换的函数)

```cpp
void cv::cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0)
```

- **InputArray src**: 输入图像，源图像可以是 `cv::Mat` 类型。这个图像需要转换颜色空间。
- **OutputArray dst**: 输出图像，目标图像可以是 `cv::Mat` 类型。这个图像将会存储转换后的结果。
- **int code**: 颜色转换代码，定义了从一种颜色空间转换到另一种颜色空间的方式。OpenCV 提供了许多预定义的颜色转换代码，如 `CV_BGR2GRAY`（从 BGR 转换到灰度）等。
- **int dstCn = 0**: 目标图像的通道数。默认值为 0，表示输出图像的通道数自动确定。如果你指定了一个正整数，它将强制目标图像具有这个通道数。

```c++
#include <opencv2/opencv.hpp>
#include <iostream>
using namespace std;
using namespace cv;
int main()
{
    Mat src = imread("../222.png", 1);
    if (src.empty()) {
        cout << "图片不存在" << endl;
        return -1;
    }
    namedWindow("image", WINDOW_AUTOSIZE);
    cvtColor(src, src, COLOR_RGB2GRAY);
    imshow("image", src);
    int key = waitKey(0);
    if (key == 27) { // ESC 键
        destroyAllWindows();
    }
    else if (key == 's' || key == 'S') { // 's' 键或 'S' 键
        imwrite("imagechange.png", src);
        destroyAllWindows();
    }
    return 0;
}
```

#### 1.1.2 **`convertTo`**  (将矩阵的数据类型转换为另一种数据类型)

**`convertTo`** 是 OpenCV 中 `cv::Mat` 类的一个成员函数，用于将矩阵的数据类型转换为另一种数据类型，同时可以对每个元素应用可选的缩放和偏移操作。该函数的原型如下：

```cpp
void cv::Mat::convertTo(OutputArray dst, int rtype, double alpha = 1, double beta = 0) const;
```

- **OutputArray dst**: 输出矩阵。目标矩阵类型可以是 `cv::Mat`，该矩阵将包含转换后的数据。
- **int rtype**: 输出矩阵的数据类型。例如，`CV_8U`、`CV_32F` 等。如果 rtype 是负数，输出矩阵将具有与输入矩阵相同的类型。
- **double alpha = 1**: 可选缩放因子，默认值为 1。每个元素将乘以这个因子。
- **double beta = 0**: 可选偏移量，默认值为 0。这个值将加到每个元素上。

```cpp
#include <opencv2/opencv.hpp>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 创建目标矩阵
    cv::Mat dst;
    // 将图像数据类型从 CV_8U 转换为 CV_32F，并应用缩放和偏移
    src.convertTo(dst, CV_32F, 1.0 / 255.0, 0);
    // 显示原始图像和转换后的图像
    cv::imshow("Original Image", src);
    cv::imshow("Converted Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 1.2 多通道分离与合并

#### 1.2.1 **`split()`**   (将多通道数组分解为几个单通道数组)

**`split()`** 是 OpenCV 中的一个函数，用于将多通道数组（如彩色图像）分解为几个单通道数组（如单通道图像）。它的函数原型如下：

```cpp
void cv::split(const Mat& src, OutputArrayOfArrays mv);
```

- **const Mat& src**: 输入多通道数组（例如，彩色图像可以是一个 `cv::Mat` 类型的对象，它有多个通道）。
- **OutputArrayOfArrays mv**: 输出数组或向量。这个参数将包含分解后的单通道数组。

```cpp
#include <opencv2/opencv.hpp>
int main() {
    // 读取彩色图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 创建一个包含三个 Mat 对象的向量
    std::vector<cv::Mat> channels;
    // 将彩色图像分解为三个单通道图像
    cv::split(src, channels);
    // 显示每个通道的图像
    cv::imshow("Blue Channel", channels[0]);
    cv::imshow("Green Channel", channels[1]);
    cv::imshow("Red Channel", channels[2]);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 1.2.2 **`merge()`**  (将多个单通道数组合并为一个多通道数组)

**`merge()`** 是 OpenCV 中的一个函数，用于将多个单通道数组合并为一个多通道数组。

```cpp
void cv::merge(const std::vector<Mat>& mv, OutputArray dst);
```

- **const std::vector\<Mat\>& mv**: 输入的单通道数组向量。每个元素都是一个 `cv::Mat` 类型的对象，表示一个单通道图像。这些图像必须具有相同的大小和类型。
- **OutputArray dst**: 输出的多通道数组（例如，合并后的彩色图像）。该输出图像将具有与输入图像相同的大小和类型，但通道数等于输入向量的大小。
以下示例展示了如何使用 `merge()` 函数将三个单通道图像（蓝色、绿色和红色通道）合并为一个 BGR 彩色图像。

```cpp
#include <opencv2/opencv.hpp>
#include <vector>
int main() {
    // 创建三个单通道图像
    cv::Mat blueChannel = cv::Mat::zeros(100, 100, CV_8UC1);
    cv::Mat greenChannel = cv::Mat::zeros(100, 100, CV_8UC1);
    cv::Mat redChannel = cv::Mat::zeros(100, 100, CV_8UC1);
    // 设置一些示例值
    blueChannel.setTo(cv::Scalar(255)); // 将蓝色通道的值设置为 255
    greenChannel.setTo(cv::Scalar(0));  // 将绿色通道的值设置为 0
    redChannel.setTo(cv::Scalar(0));    // 将红色通道的值设置为 0
    // 将单通道图像放入向量
    std::vector<cv::Mat> channels;
    channels.push_back(blueChannel);
    channels.push_back(greenChannel);
    channels.push_back(redChannel);
    // 合并单通道图像
    cv::Mat mergedImage;
    cv::merge(channels, mergedImage);
    // 显示合并后的图像
    cv::imshow("Merged Image", mergedImage);
    cv::waitKey(0);
    return 0;
}
```

## 2. 图像像素操作处理

### 2.1 图像像素统计

#### 2.1.1 **`cv::minMaxLoc()`** (用于在单通道数组中查找最小值和最大值及其位置)

**`cv::minMaxLoc()`** 是 OpenCV 中的一个函数，**用于在单通道数组中查找最小值和最大值及其位置**。它的函数原型如下：

```cpp
void cv::minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc = 0, Point* maxLoc = 0, InputArray mask = noArray());
```

- **InputArray src**: 输入的单通道数组（例如，灰度图像）。
- **double* minVal**: 输出参数，指向最小值的指针。
- **double* maxVal**: 输出参数，指向最大值的指针。
- **Point* minLoc**: 输出参数，指向最小值位置的指针。
- **Point* maxLoc**: 输出参数，指向最大值位置的指针。
- **InputArray mask**: 可选的操作掩码，用于指定要查找最小值和最大值的区域。
以下是一个**示例代码**，展示如何使用 `cv::minMaxLoc()` 来查找图像中的最小值和最大值及其位置：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat image = cv::imread("path/to/image.jpg", cv::IMREAD_GRAYSCALE);
    // 检查图像是否读取成功
    if (image.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 查找最小值和最大值及其位置
    double minVal, maxVal;
    cv::Point minLoc, maxLoc;
    cv::minMaxLoc(image, &minVal, &maxVal, &minLoc, &maxLoc);
    // 打印最小值和最大值及其位置
    std::cout << "Min value: " << minVal << " at (" << minLoc.x << ", " << minLoc.y << ")" << std::endl;
    std::cout << "Max value: " << maxVal << " at (" << maxLoc.x << ", " << maxLoc.y << ")" << std::endl;
    // 显示图像
    cv::imshow("Image", image);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 1.2.2 **`cv::reshape()`**  (用于更改矩阵的形状而不改变其数据的总数或内容)

**`cv::reshape()`** 是 OpenCV 中的一个函数，用于更改矩阵的形状（即行和列的数目）而不改变其数据的总数或内容。这个函数在矩阵重排和数据处理时非常有用。`reshape()` 函数通过改变矩阵的形状来创建一个新的矩阵，而不改变其数据的总数或内容。它可以用于将多通道图像转换为单通道图像，或者调整矩阵的行数和列数。

```cpp
Mat cv::reshape(int cn, int rows = 0) const;
```

- **int cn**: 输出矩阵的通道数。它可以与输入矩阵的通道数不同。
- **int rows**: 输出矩阵的行数。如果为 0，则行数会自动计算。
以下是一个**示例代码**，展示如何使用 `cv::reshape()` 将一个多通道图像转换为单通道矩阵，以及如何改变矩阵的行数和列数：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取彩色图像
    cv::Mat image = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (image.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 显示原始图像
    cv::imshow("Original Image", image);
    // 将多通道图像转换为单通道矩阵
    cv::Mat reshaped1 = image.reshape(1, image.rows * image.cols);
    std::cout << "Reshaped to single channel matrix with " << reshaped1.rows << " rows and " << reshaped1.cols << " cols." << std::endl;
    // 改变矩阵的行数和列数
    int newRows = image.rows * image.cols / 3;
    cv::Mat reshaped2 = image.reshape(3, newRows);
    std::cout << "Reshaped to " << reshaped2.rows << " rows and " << reshaped2.cols << " cols with 3 channels." << std::endl;
    // 等待按键事件
    cv::waitKey(0);
    return 0;
}
```

#### 1.2.3 **`cv::mean()`**  (用于计算数组元素的平均值)

**`cv::mean()`** 是 OpenCV 中的一个函数，**用于计算数组元素的平均值**。它可以用于计算图像或矩阵中所有元素的平均值，也可以使用掩码来计算特定区域的平均值。- **Scalar**: 返回一个 `cv::Scalar` 对象，包含输入数组每个通道的平均值。

```cpp
Scalar cv::mean(InputArray src, InputArray mask = noArray());
```

- **InputArray src**: 输入数组（例如，图像或矩阵）。
- **InputArray mask**: 可选的操作掩码，指定要计算平均值的区域。如果没有提供掩码，将计算整个输入数组的平均值。
以下是一个**示例代码**，展示如何使用 `cv::mean()` 计算彩色图像和灰度图像的平均值：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取彩色图像
    cv::Mat image = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (image.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 计算彩色图像的平均值
    cv::Scalar meanValue = cv::mean(image);
    std::cout << "Mean value (BGR): " << meanValue << std::endl;
    // 转换为灰度图像
    cv::Mat grayImage;
    cv::cvtColor(image, grayImage, cv::COLOR_BGR2GRAY);
    // 计算灰度图像的平均值
    meanValue = cv::mean(grayImage);
    std::cout << "Mean value (Gray): " << meanValue[0] << std::endl;
    // 显示图像
    cv::imshow("Original Image", image);
    cv::imshow("Gray Image", grayImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 1.2.4 **`cv::meanStdDev()`**  (用于计算数组元素的平均值和标准偏差)

**`cv::meanStdDev()`** 是 OpenCV 中的一个函数，用于计算数组元素的平均值和标准偏差。它可以用于计算图像或矩阵中所有元素的统计信息。下面是它的函数原型及其详细解释：

```cpp
void cv::meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask = noArray());
```

- **InputArray src**: 输入数组（例如，图像或矩阵）。
- **OutputArray mean**: 输出数组，包含每个通道的平均值。
- **OutputArray stddev**: 输出数组，包含每个通道的标准偏差。
- **InputArray mask**: 可选的操作掩码，指定要计算统计信息的区域。如果没有提供掩码，将计算整个输入数组的统计信息。
以下是一个**示例代码**，展示如何使用 `cv::meanStdDev()` 计算彩色图像和灰度图像的平均值和标准偏差：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取彩色图像
    cv::Mat image = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (image.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 计算彩色图像的平均值和标准偏差
    cv::Scalar meanValue, stddevValue;
    cv::meanStdDev(image, meanValue, stddevValue);
    std::cout << "Mean value (BGR): " << meanValue << std::endl;
    std::cout << "Standard deviation (BGR): " << stddevValue << std::endl;
    // 转换为灰度图像
    cv::Mat grayImage;
    cv::cvtColor(image, grayImage, cv::COLOR_BGR2GRAY);
    // 计算灰度图像的平均值和标准偏差
    cv::meanStdDev(grayImage, meanValue, stddevValue);
    std::cout << "Mean value (Gray): " << meanValue[0] << std::endl;
    std::cout << "Standard deviation (Gray): " << stddevValue[0] << std::endl;
    // 显示图像
    cv::imshow("Original Image", image);
    cv::imshow("Gray Image", grayImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 2.2 两个图像的比较运算

#### 2.2.1 **`cv::max()`**  (用于计算两个数组逐元素的最大值)

**`cv::max()`** 是 OpenCV 中的一个函数，用于计算两个数组逐元素的最大值。它可以用于将两个图像或矩阵逐元素比较，并返回一个新的矩阵，其中每个元素都是两个输入矩阵对应元素中的较大值。下面是它的函数原型及其详细解释：

```cpp
void cv::max(InputArray src1, InputArray src2, OutputArray dst);
```

- **InputArray src1**: 第一个输入数组（图像或矩阵）。
- **InputArray src2**: 第二个输入数组（图像或矩阵）。
- **OutputArray dst**: 输出数组，存储逐元素最大值的结果。
以下是一个**示例代码**，展示如何使用 `cv::max()` 函数计算两个图像的逐元素最大值：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取两幅图像
    cv::Mat image1 = cv::imread("path/to/image1.jpg");
    cv::Mat image2 = cv::imread("path/to/image2.jpg");
    // 检查图像是否读取成功
    if (image1.empty() || image2.empty()) {
        std::cerr << "Error: Could not open or find the images." << std::endl;
        return -1;
    }
    // 确保两幅图像具有相同的尺寸和类型
    if (image1.size() != image2.size() || image1.type() != image2.type()) {
        std::cerr << "Error: The images must have the same size and type." << std::endl;
        return -1;
    }
    // 计算逐元素最大值
    cv::Mat maxImage;
    cv::max(image1, image2, maxImage);
    // 显示图像
    cv::imshow("Image 1", image1);
    cv::imshow("Image 2", image2);
    cv::imshow("Max Image", maxImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 2.2.2 **`cv::min()`**  (用于计算两个数组逐元素的最小值)

**`cv::min()`** 是 OpenCV 中的一个函数，用于计算两个数组逐元素的最小值。它可以用于将两个图像或矩阵逐元素比较，并返回一个新的矩阵，其中每个元素都是两个输入矩阵对应元素中的较小值。下面是它的函数原型及其详细解释：

```cpp
void cv::min(InputArray src1, InputArray src2, OutputArray dst);
```

- **InputArray src1**: 第一个输入数组（图像或矩阵）。
- **InputArray src2**: 第二个输入数组（图像或矩阵）。
- **OutputArray dst**: 输出数组，存储逐元素最小值的结果。
以下是一个**示例代码**，展示如何使用 `cv::min()` 函数计算两个图像的逐元素最小值：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取两幅图像
    cv::Mat image1 = cv::imread("path/to/image1.jpg");
    cv::Mat image2 = cv::imread("path/to/image2.jpg");
    // 检查图像是否读取成功
    if (image1.empty() || image2.empty()) {
        std::cerr << "Error: Could not open or find the images." << std::endl;
        return -1;
    }
    // 确保两幅图像具有相同的尺寸和类型
    if (image1.size() != image2.size() || image1.type() != image2.type()) {
        std::cerr << "Error: The images must have the same size and type." << std::endl;
        return -1;
    }
    // 计算逐元素最小值
    cv::Mat minImage;
    cv::min(image1, image2, minImage);
    // 显示图像
    cv::imshow("Image 1", image1);
    cv::imshow("Image 2", image2);
    cv::imshow("Min Image", minImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

在 OpenCV 中，**`bitwise_and`**、**`bitwise_or`**、**`bitwise_xor`** 和 **`bitwise_not`** 是用于对图像或数组进行按位操作的函数。它们可以用于处理图像中的像素级别的逻辑运算或颜色通道处理。以下是它们的函数原型及功能解释：

#### 2.2.3 bitwise_and

```cpp
void cv::bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray());
```

- **功能**: 计算两个数组或图像逐元素的按位与操作。
- **参数**:
  - **InputArray src1**: 第一个输入数组或图像。
  - **InputArray src2**: 第二个输入数组或图像。
  - **OutputArray dst**: 输出数组或图像，存储按位与操作的结果。
  - **InputArray mask**: 可选的操作掩码，用于指定要应用的像素区域。

#### 2.2.4 bitwise_or

```cpp
void cv::bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray());
```

- **功能**: 计算两个数组或图像逐元素的按位或操作。
- **参数**:
  - **InputArray src1**: 第一个输入数组或图像。
  - **InputArray src2**: 第二个输入数组或图像。
  - **OutputArray dst**: 输出数组或图像，存储按位或操作的结果。
  - **InputArray mask**: 可选的操作掩码，用于指定要应用的像素区域。

#### 2.2.5 bitwise_xor

```cpp
void cv::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray());
```

- **功能**: 计算两个数组或图像逐元素的按位异或操作。
- **参数**:
  - **InputArray src1**: 第一个输入数组或图像。
  - **InputArray src2**: 第二个输入数组或图像。
  - **OutputArray dst**: 输出数组或图像，存储按位异或操作的结果。
  - **InputArray mask**: 可选的操作掩码，用于指定要应用的像素区域。

#### 2.2.6 bitwise_not

```cpp
void cv::bitwise_not(InputArray src, OutputArray dst, InputArray mask = noArray());
```

- **功能**: 计算数组或图像逐元素的按位非操作。
- **参数**:
  - **InputArray src**: 输入数组或图像。
  - **OutputArray dst**: 输出数组或图像，存储按位非操作的结果。
  - **InputArray mask**: 可选的操作掩码，用于指定要应用的像素区域。
以下是一个**示例代码**，展示如何使用这些按位操作函数：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 创建两个图像
    cv::Mat image1 = cv::imread("path/to/image1.jpg", cv::IMREAD_GRAYSCALE);
    cv::Mat image2 = cv::imread("path/to/image2.jpg", cv::IMREAD_GRAYSCALE);
    // 检查图像是否读取成功
    if (image1.empty() || image2.empty()) {
        std::cerr << "Error: Could not open or find the images." << std::endl;
        return -1;
    }
    // 确保两幅图像具有相同的尺寸和类型
    if (image1.size() != image2.size()) {
        std::cerr << "Error: The images must have the same size." << std::endl;
        return -1;
    }
    // 定义输出图像
    cv::Mat andImage, orImage, xorImage, notImage;
    // 计算按位与
    cv::bitwise_and(image1, image2, andImage);
    // 计算按位或
    cv::bitwise_or(image1, image2, orImage);
    // 计算按位异或
    cv::bitwise_xor(image1, image2, xorImage);
    // 计算按位非
    cv::bitwise_not(image1, notImage);
    // 显示图像
    cv::imshow("Image 1", image1);
    cv::imshow("Image 2", image2);
    cv::imshow("Bitwise AND", andImage);
    cv::imshow("Bitwise OR", orImage);
    cv::imshow("Bitwise XOR", xorImage);
    cv::imshow("Bitwise NOT", notImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 2.3 图像二值化

#### 2.3.1 `cv::threshold()`  (根据指定的阈值将输入图像的像素值转换为二进制形式或者截断形式)

`cv::threshold()` 是 OpenCV 中用于图像阈值处理的函数，它可以根据指定的阈值将输入图像的像素值转换为二进制形式或者截断形式。返回**double**: 返回所选的阈值。

```cpp
double cv::threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type);
```

- **InputArray src**: 输入的单通道图像（灰度图像）。
- **OutputArray dst**: 输出的二值化图像，与输入图像有相同的尺寸和类型。
- **double thresh**: 阈值，用于比较像素值。根据不同的 `type` 参数，阈值的含义会有所不同。
- **double maxval**: 如果选择的阈值类型是 `THRESH_BINARY` 或 `THRESH_BINARY_INV`，则用来给超过（或未超过）阈值的像素赋予的值。
- **int type**: 阈值类型，可以是以下之一：
  - `THRESH_BINARY`: 将大于阈值的像素值设为 `maxval`，小于或等于阈值的像素值设为 0。
  - `THRESH_BINARY_INV`: 将小于阈值的像素值设为 `maxval`，大于或等于阈值的像素值设为 0。
  - `THRESH_TRUNC`: 将大于阈值的像素值截断为阈值，小于等于阈值的保持不变。
  - `THRESH_TOZERO`: 将大于阈值的像素值保持不变，小于等于阈值的像素值设为 0。
  - `THRESH_TOZERO_INV`: 将小于阈值的像素值保持不变，大于等于阈值的像素值设为 0。
  - `THRESH_OTSU`: 大津法自动寻求全局阈值。
  - `THRESH_TRIANGLE`: 三角形自动寻求全局阈值 。
以下是一个**示例代码**，展示如何使用 `cv::threshold()` 对灰度图像进行阈值处理：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取灰度图像
    cv::Mat grayImage = cv::imread("path/to/gray_image.jpg", cv::IMREAD_GRAYSCALE);
    // 检查图像是否读取成功
    if (grayImage.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 创建输出图像
    cv::Mat binaryImage;
    // 设置阈值和类型
    double thresh = 127;
    double maxval = 255;
    int thresholdType = cv::THRESH_BINARY; // 或者可以选择其他阈值类型
    // 应用阈值处理
    double thresholdValue = cv::threshold(grayImage, binaryImage, thresh, maxval, thresholdType);
    // 显示图像
    cv::imshow("Gray Image", grayImage);
    cv::imshow("Binary Image", binaryImage);
    std::cout << "Threshold value used: " << thresholdValue << std::endl;
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 2.3.2 **`cv::adaptiveThreshold()`**  (用于自适应阈值处理的函数)

**`cv::adaptiveThreshold()`** 是 OpenCV 中用于自适应阈值处理的函数。与 `cv::threshold()` 不同，`cv::adaptiveThreshold()` 根据图像的不同区域计算不同的阈值，从而在具有不均匀光照的图像中表现得更好。

```cpp
void cv::adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C);
```

- **InputArray src**: 输入的单通道图像（灰度图像）。
- **OutputArray dst**: 输出的二值化图像，与输入图像有相同的尺寸和类型。
- **double maxValue**: 阈值操作中使用的最大值。
- **int adaptiveMethod**: 自适应阈值计算方法，可以是以下之一：
  - `ADAPTIVE_THRESH_MEAN_C`: 使用区域的平均值减去常数 `C` 作为阈值。
  - `ADAPTIVE_THRESH_GAUSSIAN_C`: 使用区域的加权平均值（高斯窗口）减去常数 `C` 作为阈值。
- **int thresholdType**: 阈值类型，可以是以下之一：
  - `THRESH_BINARY`: 将大于阈值的像素值设为 `maxValue`，小于或等于阈值的像素值设为 0。
  - `THRESH_BINARY_INV`: 将小于阈值的像素值设为 `maxValue`，大于或等于阈值的像素值设为 0。
- **int blockSize**: 用于计算阈值的区域大小（一个正奇数）。
- **double C**: 常数，从计算出的平均值或加权平均值中减去，用于调整阈值。
以下是一个**示例代码**，展示如何使用 `cv::adaptiveThreshold()` 对灰度图像进行自适应阈值处理：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取灰度图像
    cv::Mat grayImage = cv::imread("path/to/gray_image.jpg", cv::IMREAD_GRAYSCALE);
    // 检查图像是否读取成功
    if (grayImage.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 创建输出图像
    cv::Mat adaptiveBinaryImage;
    // 设置参数
    double maxValue = 255;
    int adaptiveMethod = cv::ADAPTIVE_THRESH_GAUSSIAN_C; // 或者使用 cv::ADAPTIVE_THRESH_MEAN_C
    int thresholdType = cv::THRESH_BINARY;
    int blockSize = 11; // 区域大小，必须是奇数
    double C = 2; // 常数
    // 应用自适应阈值处理
    cv::adaptiveThreshold(grayImage, adaptiveBinaryImage, maxValue, adaptiveMethod, thresholdType, blockSize, C);
    // 显示图像
    cv::imshow("Gray Image", grayImage);
    cv::imshow("Adaptive Binary Image", adaptiveBinaryImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 2.3.3 **`cv::LUT()`**  (用于查找表操作（Lookup Table）的函数)

**`cv::LUT()`** 是 OpenCV 中用于查找表操作（Lookup Table）的函数。它允许你通过预定义的查找表将输入图像中的像素值转换为新的值。该函数非常有用，特别是在需要进行非线性映射或色彩校正时。

```cpp
void cv::LUT(InputArray src, InputArray lut, OutputArray dst);
```

- **InputArray src**: 输入的单通道或多通道图像。
- **InputArray lut**: 查找表，必须是 256×1 或 1×256 大小的单通道图像。
- **OutputArray dst**: 输出图像，与输入图像有相同的尺寸和类型。
以下是一个**示例代码**，展示如何使用 `cv::LUT()` 函数进行图像的查找表操作：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取输入图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 创建查找表
    cv::Mat lut(1, 256, CV_8UC1);
    for (int i = 0; i < 256; ++i) {
        lut.at<uchar>(i) = 255 - i; // 反转像素值
    }
    // 创建输出图像
    cv::Mat dst;
    // 应用查找表
    cv::LUT(src, lut, dst);
    // 显示图像
    cv::imshow("Source Image", src);
    cv::imshow("LUT Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

## 3. 图像变换

### 3.1 图像连接

#### 3.1.1 `cv::vconcat`(用于在垂直方向上拼接多个矩阵的函数)

`cv::vconcat()` 是 OpenCV 中用于在垂直方向上拼接两个或多个矩阵的函数。它允许你将多张图像或矩阵按垂直顺序拼接在一起，形成一个新的矩阵。

```cpp
void cv::vconcat(InputArray src1, InputArray src2, OutputArray dst);
void cv::vconcat(const std::vector<Mat>& src, OutputArray dst);
```

- **InputArray src1**: 第一个输入矩阵或图像。
- **InputArray src2**: 第二个输入矩阵或图像。
- **OutputArray dst**: 输出矩阵或图像，包含拼接后的结果。
- **`const std::vector<Mat>&  src`**: 一个包含多个输入矩阵或图像的向量。
以下是一个**示例代码**，展示如何使用 `cv::vconcat()` 函数进行图像的垂直拼接：

```C++
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat img1 = cv::imread("path/to/image1.jpg");
    cv::Mat img2 = cv::imread("path/to/image2.jpg");
    // 检查图像是否读取成功
    if (img1.empty() || img2.empty()) {
        std::cerr << "Error: Could not open or find the image(s)." << std::endl;
        return -1;
    }
    // 将图像在垂直方向上拼接
    cv::Mat concatenatedImg;
    cv::vconcat(img1, img2, concatenatedImg);
    // 显示拼接后的图像
    cv::imshow("Concatenated Image", concatenatedImg);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

##### 使用 `std::vector` 方式的示例代码

以下是使用包含多个矩阵或图像的 `std::vector` 来进行垂直拼接的示例代码：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

int main() {
    // 读取图像
    cv::Mat img1 = cv::imread("path/to/image1.jpg");
    cv::Mat img2 = cv::imread("path/to/image2.jpg");
    // 检查图像是否读取成功
    if (img1.empty() || img2.empty()) {
        std::cerr << "Error: Could not open or find the image(s)." << std::endl;
        return -1;
    }
    // 创建图像向量并添加图像
    std::vector<cv::Mat> images = {img1, img2};
    // 将图像在垂直方向上拼接
    cv::Mat concatenatedImg;
    cv::vconcat(images, concatenatedImg);
    // 显示拼接后的图像
    cv::imshow("Concatenated Image", concatenatedImg);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 3.1.2 `cv::hconcat()`(用于在水平方向上拼接两个或多个矩阵的函数)

`cv::hconcat()` 是 OpenCV 中用于在水平方向上拼接两个或多个矩阵的函数。它允许你将多张图像或矩阵按水平方向拼接在一起，形成一个新的矩阵。

```cpp
void cv::hconcat(InputArray src1, InputArray src2, OutputArray dst);
void cv::hconcat(const std::vector<Mat>& src, OutputArray dst);
```

- **InputArray src1**: 第一个输入矩阵或图像。
- **InputArray src2**: 第二个输入矩阵或图像。
- **OutputArray dst**: 输出矩阵或图像，包含拼接后的结果。
- **`const std::vector<Mat>& src`**: 一个包含多个输入矩阵或图像的向量。
以下是一个**示例代码**，展示如何使用 `cv::hconcat()` 函数进行图像的水平拼接：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat img1 = cv::imread("path/to/image1.jpg");
    cv::Mat img2 = cv::imread("path/to/image2.jpg");
    // 检查图像是否读取成功
    if (img1.empty() || img2.empty()) {
        std::cerr << "Error: Could not open or find the image(s)." << std::endl;
        return -1;
    }
    // 将图像在水平方向上拼接
    cv::Mat concatenatedImg;
    cv::hconcat(img1, img2, concatenatedImg);
    // 显示拼接后的图像
    cv::imshow("Concatenated Image", concatenatedImg);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 使用 `std::vector` 方式的示例代码

以下是使用包含多个矩阵或图像的 `std::vector` 来进行水平拼接的**示例代码**：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

int main() {
    // 读取图像
    cv::Mat img1 = cv::imread("path/to/image1.jpg");
    cv::Mat img2 = cv::imread("path/to/image2.jpg");
    // 检查图像是否读取成功
    if (img1.empty() || img2.empty()) {
        std::cerr << "Error: Could not open or find the image(s)." << std::endl;
        return -1;
    }
    // 创建图像向量并添加图像
    std::vector<cv::Mat> images = {img1, img2};
    // 将图像在水平方向上拼接
    cv::Mat concatenatedImg;
    cv::hconcat(images, concatenatedImg);
    // 显示拼接后的图像
    cv::imshow("Concatenated Image", concatenatedImg);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 3.1.3 `cv::resize()`(用于调整图像大小的函数)

`cv::resize()` 是 OpenCV 中用于调整图像大小的函数。它可以缩放或缩小图像，使其具有指定的宽度和高度，或按比例缩放。

```cpp
void cv::resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR);
```

- **InputArray src**: 输入的源图像。
- **OutputArray dst**: 输出的目标图像。
- **Size dsize**: 输出图像的尺寸。`dsize` 可以是 `(width, height)`。
- **double fx**: 水平方向上的缩放因子。
- **double fy**: 垂直方向上的缩放因子。
- **int interpolation**: 插值方法。常用的方法有 `INTER_NEAREST`, `INTER_LINEAR`, `INTER_AREA`, `INTER_CUBIC`, 和 `INTER_LANCZOS4`。
以下是一个**示例代码**，展示如何使用 `cv::resize()` 函数调整图像大小：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 缩放因子
    double fx = 0.5;
    double fy = 0.5;
    // 调整图像大小
    cv::Mat resizedImg;
    cv::resize(src, resizedImg, cv::Size(), fx, fy, cv::INTER_LINEAR);
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Resized Image", resizedImg);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 指定输出尺寸

也可以通过指定输出图像的尺寸来调整图像大小：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 指定输出尺寸
    cv::Size dsize(800, 600);
    // 调整图像大小
    cv::Mat resizedImg;
    cv::resize(src, resizedImg, dsize, 0, 0, cv::INTER_LINEAR);
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Resized Image", resizedImg);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

#### 插值方法

- **`INTER_NEAREST`**: 最近邻插值。
- **`INTER_LINEAR`**: 双线性插值（默认）。
- **`INTER_AREA`**: 像素区域关系重采样。对图像缩小有很好的效果。
- **`INTER_CUBIC`**: 4×4 像素邻域的双三次插值。
- **`INTER_LANCZOS4`**: 8×8 像素邻域的 Lanczos 插值。

### 3.1.4 `cv::flip()`(用于对图像进行翻转操作的函数)

`cv::flip()` 是 OpenCV 中用于对图像进行翻转操作的函数。它可以对图像进行水平、垂直或水平垂直同时翻转。

```cpp
void cv::flip(InputArray src, OutputArray dst, int flipCode);
```

- **InputArray src**: 输入的源图像。
- **OutputArray dst**: 输出的目标图像。
- **int flipCode**: 翻转代码，用于指定翻转方向：
  - **0**: 垂直翻转。
  - **1**: 水平翻转。
  - **-1**: 水平和垂直同时翻转。
以下是一个**示例代码**，展示如何使用 `cv::flip()` 函数对图像进行不同方向的翻转：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 垂直翻转
    cv::Mat dst_vertical;
    cv::flip(src, dst_vertical, 0);
    // 水平翻转
    cv::Mat dst_horizontal;
    cv::flip(src, dst_horizontal, 1);
    // 水平和垂直同时翻转
    cv::Mat dst_both;
    cv::flip(src, dst_both, -1);
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Vertical Flip", dst_vertical);
    cv::imshow("Horizontal Flip", dst_horizontal);
    cv::imshow("Both Flip", dst_both);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 3.1.5 `cv::getRotationMatrix2D()`(用于生成旋转矩阵的函数)

`cv::getRotationMatrix2D()` 是 OpenCV 中用于生成旋转矩阵的函数，该矩阵可以用于旋转图像。通过指定旋转中心、旋转角度和缩放因子，你可以获得一个 2x3 的仿射变换矩阵，用于后续的图像旋转操作。

```cpp
cv::Mat cv::getRotationMatrix2D(Point2f center, double angle, double scale);
```

- **Point2f center**: 旋转中心点，通常是图像的中心。
- **double angle**: 旋转角度，顺时针方向为正，单位为度。
- **double scale**: 缩放因子，用于调整旋转后的图像大小。
以下是一个**示例代码**，展示如何使用 `cv::getRotationMatrix2D()` 函数生成旋转矩阵并应用到图像上：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 指定旋转中心、角度和缩放因子
    cv::Point2f center(src.cols / 2.0, src.rows / 2.0);
    double angle = 45.0; // 旋转45度
    double scale = 1.0;  // 不缩放
    // 获取旋转矩阵
    cv::Mat rotationMatrix = cv::getRotationMatrix2D(center, angle, scale);
    // 计算旋转后的图像尺寸
    cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), src.size(), angle).boundingRect2f();
    // 调整旋转矩阵
    rotationMatrix.at<double>(0, 2) += bbox.width / 2.0 - src.cols / 2.0;
    rotationMatrix.at<double>(1, 2) += bbox.height / 2.0 - src.rows / 2.0;
    // 应用旋转矩阵
    cv::Mat dst;
    cv::warpAffine(src, dst, rotationMatrix, bbox.size());
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Rotated Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 3.1.6 `cv::warpAffine()`(用于对图像进行仿射变换的函数)

`cv::warpAffine()` 是 OpenCV 中用于对图像进行仿射变换的函数，可以实现平移、旋转、缩放等操作。

```cpp
void cv::warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar());
```

- **InputArray src**: 输入的源图像。
- **OutputArray dst**: 输出的目标图像。
- **InputArray M**: 2x3 的仿射变换矩阵，可以通过 `cv::getRotationMatrix2D()` 或其他方式生成。
- **Size dsize**: 输出图像的尺寸。
- **int flags**: 插值方法，可以是 `INTER_NEAREST`, `INTER_LINEAR`, `INTER_CUBIC` 等。
- **int borderMode**: 边界模式，用于处理超出边界的像素。
- **Scalar borderValue**: 边界填充值，当 `borderMode` 设置为 `BORDER_CONSTANT` 时使用。
以下是一个**示例代码**，展示如何使用 `cv::warpAffine()` 函数对图像进行旋转：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 指定旋转中心、角度和缩放因子
    cv::Point2f center(src.cols / 2.0, src.rows / 2.0);
    double angle = 45.0; // 旋转45度
    double scale = 1.0;  // 不缩放
    // 获取旋转矩阵
    cv::Mat rotationMatrix = cv::getRotationMatrix2D(center, angle, scale);
    // 计算旋转后的图像尺寸
    cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), src.size(), angle).boundingRect2f();
    // 调整旋转矩阵
    rotationMatrix.at<double>(0, 2) += bbox.width / 2.0 - src.cols / 2.0;
    rotationMatrix.at<double>(1, 2) += bbox.height / 2.0 - src.rows / 2.0;
    // 应用仿射变换
    cv::Mat dst;
    cv::warpAffine(src, dst, rotationMatrix, src.size(), cv::INTER_LINEAR, cv::BORDER_CONSTANT, cv::Scalar());
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Rotated Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 3.1.7 `cv::getAffineTransform()`(用于生成仿射变换矩阵的函数)

`cv::getAffineTransform()` 是 OpenCV 中用于生成仿射变换矩阵的函数，该矩阵可以用于对图像进行平移、旋转和缩放等仿射变换操作。

```cpp
cv::Mat cv::getAffineTransform(const Point2f src[], const Point2f dst[]);
```

- **`const Point2f src[]`**: 源图像中的三个点，用于定义原始三角形。
- **`const Point2f dst[]`**: 目标图像中的三个点，用于定义目标三角形。
以下是一个**示例代码**，展示如何使用 `cv::getAffineTransform()` 函数生成仿射变换矩阵，并应用到图像上：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 定义原始三角形的三个点和目标三角形的三个点
    cv::Point2f src[3], dst[3];
    src[0] = cv::Point2f(50, 50);
    src[1] = cv::Point2f(200, 50);
    src[2] = cv::Point2f(50, 200);
    dst[0] = cv::Point2f(70, 100);
    dst[1] = cv::Point2f(220, 60);
    dst[2] = cv::Point2f(150, 180);
    // 获取仿射变换矩阵
    cv::Mat affineMatrix = cv::getAffineTransform(src, dst);
    // 读取图像
    cv::Mat srcImage = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (srcImage.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 应用仿射变换
    cv::Mat dstImage;
    cv::warpAffine(srcImage, dstImage, affineMatrix, srcImage.size());
    // 显示图像
    cv::imshow("Original Image", srcImage);
    cv::imshow("Transformed Image", dstImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

## 3.5 图像透视变换

### 3.5.1 `cv::getPerspectiveTransform()`

`cv::getPerspectiveTransform()` 是 OpenCV 中用于生成透视变换矩阵的函数，该矩阵可以用于对图像进行透视变换，如图像校正、景深效果等。

```cpp
cv::Mat cv::getPerspectiveTransform(const Point2f src[], const Point2f dst[]);
```

- **`const Point2f src[]`**: 源图像中的四个点，用于定义原始四边形。
- **`const Point2f dst[]`**: 目标图像中的四个点，用于定义目标四边形。
以下是一个**示例代码**，展示如何使用 `cv::getPerspectiveTransform()` 函数生成透视变换矩阵，并应用到图像上：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 定义原始四边形的四个点和目标四边形的四个点
    cv::Point2f src[4], dst[4];
    src[0] = cv::Point2f(50, 50);
    src[1] = cv::Point2f(200, 50);
    src[2] = cv::Point2f(50, 200);
    src[3] = cv::Point2f(200, 200);
    dst[0] = cv::Point2f(0, 0);
    dst[1] = cv::Point2f(300, 0);
    dst[2] = cv::Point2f(0, 300);
    dst[3] = cv::Point2f(300, 300);
    // 获取透视变换矩阵
    cv::Mat perspectiveMatrix = cv::getPerspectiveTransform(src, dst);
    // 读取图像
    cv::Mat srcImage = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (srcImage.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 应用透视变换
    cv::Mat dstImage;
    cv::warpPerspective(srcImage, dstImage, perspectiveMatrix, cv::Size(300, 300));
    // 显示图像
    cv::imshow("Original Image", srcImage);
    cv::imshow("Transformed Image", dstImage);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 3.5.2 `cv::warpPerspective()` (用于对图像进行透视变换的函数)

`cv::warpPerspective()` 是 OpenCV 中用于对图像进行透视变换的函数，它可以通过指定透视变换矩阵将原始图像投影到目标图像上。

```cpp
void cv::warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags=INTER_LINEAR, int borderMode=BORDER_CONSTANT, const Scalar& borderValue=Scalar());
```

- **InputArray src**: 输入的源图像。
- **OutputArray dst**: 输出的目标图像。
- **InputArray M**: 3x3 的透视变换矩阵。
- **Size dsize**: 输出图像的尺寸。
- **int flags**: 插值方法，可以是 `INTER_NEAREST`, `INTER_LINEAR`, `INTER_CUBIC` 等。
- **int borderMode**: 边界模式，用于处理超出边界的像素。
- **Scalar borderValue**: 边界填充值，当 `borderMode` 设置为 `BORDER_CONSTANT` 时使用。
以下是一个**示例代码**，展示如何使用 `cv::warpPerspective()` 函数对图像进行透视变换：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg");
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 定义原始四边形的四个点和目标四边形的四个点
    cv::Point2f srcPoints[4], dstPoints[4];
    srcPoints[0] = cv::Point2f(50, 50);
    srcPoints[1] = cv::Point2f(src.cols - 50, 50);
    srcPoints[2] = cv::Point2f(50, src.rows - 50);
    srcPoints[3] = cv::Point2f(src.cols - 50, src.rows - 50);
    dstPoints[0] = cv::Point2f(0, 0);
    dstPoints[1] = cv::Point2f(src.cols, 0);
    dstPoints[2] = cv::Point2f(0, src.rows);
    dstPoints[3] = cv::Point2f(src.cols, src.rows);
    // 获取透视变换矩阵
    cv::Mat perspectiveMatrix = cv::getPerspectiveTransform(srcPoints, dstPoints);
    // 应用透视变换
    cv::Mat dst;
    cv::warpPerspective(src, dst, perspectiveMatrix, cv::Size(src.cols, src.rows));
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Transformed Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

## 3.6 极坐标变换

### 3.6.1 `cv::warpPolar()`(用于极坐标变换的函数)

`cv::warpPolar()` 是 OpenCV 中用于极坐标变换的函数，它可以将图像从笛卡尔坐标系转换为极坐标系，或者反向转换回来。

```cpp
void cv::warpPolar(InputArray src, OutputArray dst, Size dsize, Point2f center, double maxRadius, int flags);
```

- **InputArray src**: 输入的源图像。
- **OutputArray dst**: 输出的目标图像。
- **Size dsize**: 输出图像的尺寸。
- **Point2f center**: 极坐标变换的中心点。
- **double maxRadius**: 极坐标的最大半径。
- **int flags**: 变换标志，可以是 `WARP_POLAR_LINEAR` 或 `WARP_POLAR_LOG`.
以下是一个**示例代码**，展示如何使用 `cv::warpPolar()` 函数对图像进行极坐标变换：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg", cv::IMREAD_GRAYSCALE);
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 定义极坐标变换的中心点和最大半径
    cv::Point2f center(src.cols / 2.0, src.rows / 2.0);
    double maxRadius = std::min(src.cols, src.rows) / 2.0;
    // 创建输出图像
    cv::Mat dst;
    cv::Size dsize(src.cols, src.rows); // 与输入图像大小相同
    // 应用极坐标变换
    cv::warpPolar(src, dst, dsize, center, maxRadius, cv::WARP_POLAR_LINEAR);
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Polar Transformed Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

## 4. 在图像上绘制几何图形

### 4.1.1 `cv::warpPolar()` 函数详解

**`cv::warpPolar()`** 是 OpenCV 中用于进行极坐标变换的函数。它可以将图像从笛卡尔坐标系转换为极坐标系，或者反向转换回来。

```cpp
void cv::warpPolar(InputArray src, OutputArray dst, Size dsize, Point2f center, double maxRadius, int flags);
```

- **InputArray src**: 输入的源图像。
  - **说明**: 要进行极坐标变换的原始图像。通常是灰度图像，但也可以是彩色图像。
- **OutputArray dst**: 输出的目标图像。
  - **说明**: 存储变换后的极坐标图像。图像尺寸由参数 `dsize` 指定。
- **Size dsize**: 输出图像的尺寸。
  - **说明**: 指定输出图像的大小，即目标图像的宽度和高度。
- **Point2f center**: 极坐标变换的中心点。
  - **说明**: 指定极坐标变换的中心点坐标 `(x, y)`。通常为图像的中心 `(src.cols / 2.0, src.rows / 2.0)`。
- **double maxRadius**: 极坐标的最大半径。
  - **说明**: 指定极坐标的最大半径，控制了极坐标变换后的图像大小和内容分布。
- **int flags**: 变换标志。
  - **说明**: 指定变换的类型，可以是以下常量之一：
    - `cv::WARP_POLAR_LINEAR`：线性插值模式，适用于较简单的极坐标变换。
    - `cv::WARP_POLAR_LOG`：对数插值模式，适用于包含较大范围数据的图像，如频谱分析。
以下是一个**示例代码**，展示如何使用 `cv::warpPolar()` 函数对图像进行极坐标变换：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 读取图像
    cv::Mat src = cv::imread("path/to/image.jpg", cv::IMREAD_GRAYSCALE);
    // 检查图像是否读取成功
    if (src.empty()) {
        std::cerr << "Error: Could not open or find the image." << std::endl;
        return -1;
    }
    // 定义极坐标变换的中心点和最大半径
    cv::Point2f center(src.cols / 2.0, src.rows / 2.0);
    double maxRadius = std::min(src.cols, src.rows) / 2.0;
    // 创建输出图像
    cv::Mat dst;
    cv::Size dsize(src.cols, src.rows); // 与输入图像大小相同
    // 应用极坐标变换
    cv::warpPolar(src, dst, dsize, center, maxRadius, cv::WARP_POLAR_LINEAR);
    // 显示图像
    cv::imshow("Original Image", src);
    cv::imshow("Polar Transformed Image", dst);
    cv::waitKey(0); // 等待按键事件
    return 0;
}
```

### 4.1.2 `cv::line()` (用于在图像上绘制直线的函数)

**`cv::line()`** 是 OpenCV 中用于在图像上绘制直线的函数。

```cpp
void cv::line(
    InputOutputArray img,
    Point pt1,
    Point pt2,
    const Scalar& color,
    int thickness = 1,
    int lineType = LINE_8,
    int shift = 0
);
```

- **InputOutputArray img**: 输入输出图像。
  - **说明**: 要在其上绘制直线的图像。可以是单通道或多通道图像。
- **Point pt1**: 直线的起始点坐标。
  - **说明**: 直线的起始点坐标 `(x1, y1)`。
- **Point pt2**: 直线的终止点坐标。
  - **说明**: 直线的终止点坐标 `(x2, y2)`。
- **const Scalar& color**: 直线的颜色。
  - **说明**: 直线的颜色，可以是单通道灰度值或多通道颜色值。例如，`cv::Scalar(0, 0, 255)` 表示红色。
- **int thickness**: 直线的宽度（可选）。
  - **默认值**: `1`。
  - **说明**: 直线的像素宽度。如果为负值，如 `FILLED`，表示绘制实心线条。
- **int lineType**: 直线的类型（可选）。
  - **默认值**: `LINE_8`。
  - **说明**: 直线的线型，可以是 `LINE_4`、`LINE_8`、`LINE_AA`（抗锯齿线）等之一。
- **int shift**: 坐标点的小数部分位数（可选）。
  - **默认值**: `0`。
  - **说明**: 坐标点的小数部分位数位移量。
以下是一个**示例代码**，展示如何使用 `cv::line()` 函数在图像上绘制一条蓝色的直线：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 创建一个黑色图像
    cv::Mat image = cv::Mat::zeros(400, 400, CV_8UC3);
    // 定义直线的起始点和终止点坐标
    cv::Point pt1(100, 100);
    cv::Point pt2(300, 300);
    // 绘制蓝色的直线
    cv::Scalar color(255, 0, 0); // 蓝色 BGR
    cv::line(image, pt1, pt2, color, 2); // 宽度为2像素
    // 显示图像
    cv::imshow("Line", image);
    cv::waitKey(0);
    return 0;
}
```

### `cv::ellipse()` (用于绘制椭圆的函数)

**`cv::ellipse()`** 是 OpenCV 中用于绘制椭圆的函数。

```cpp
void cv::ellipse(
    InputOutputArray img,
    Point center,
    Size axes,
    double angle,
    double startAngle,
    double endAngle,
    const Scalar& color,
    int thickness = 1,
    int lineType = LINE_8,
    int shift = 0
);
```

- **InputOutputArray img**: 输入输出图像。
  - **说明**: 要在其上绘制椭圆的图像。可以是单通道或多通道图像。
- **Point center**: 椭圆的中心点坐标。
  - **说明**: 椭圆的中心点坐标 `(x, y)`。
- **Size axes**: 椭圆的半长轴和半短轴的长度。
  - **说明**: 指定椭圆的半长轴和半短轴的长度 `(major axis length, minor axis length)`。
- **double angle**: 椭圆的旋转角度。
  - **说明**: 椭圆相对于水平轴的旋转角度。正值表示顺时针旋转。
- **double startAngle**: 椭圆弧的起始角度。
  - **说明**: 椭圆弧的起始角度，以度为单位。0 度表示水平向右。
- **double endAngle**: 椭圆弧的结束角度。
  - **说明**: 椭圆弧的结束角度，以度为单位。360 度表示一个完整的椭圆。
- **const Scalar& color**: 椭圆的颜色。
  - **说明**: 椭圆的颜色，可以是单通道灰度值或多通道颜色值。
- **int thickness**: 椭圆边界的厚度（可选）。
  - **默认值**: `1`。
  - **说明**: 椭圆边界的像素宽度。如果为负值，如 `FILLED`，表示填充整个椭圆。
- **int lineType**: 边界的类型（可选）。
  - **默认值**: `LINE_8`。
  - **说明**: 边界的线型，可以是 `LINE_4`、`LINE_8`、`LINE_AA`（抗锯齿线）等之一。
- **int shift**: 坐标点的小数部分位数（可选）。
  - **默认值**: `0`。
  - **说明**: 坐标点的小数部分位数位移量。
以下是一个**示例代码**，展示如何使用 `cv::ellipse()` 函数在图像上绘制一个红色的椭圆：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 创建一个黑色图像
    cv::Mat image = cv::Mat::zeros(400, 400, CV_8UC3);
    // 定义椭圆的参数
    cv::Point center(200, 200); // 中心点坐标
    cv::Size axes(100, 50);     // 半长轴和半短轴长度
    double angle = 30;          // 旋转角度
    double startAngle = 0;      // 起始角度
    double endAngle = 360;      // 结束角度
    // 绘制红色的椭圆
    cv::Scalar color(0, 0, 255); // 红色 BGR
    cv::ellipse(image, center, axes, angle, startAngle, endAngle, color, 2);
    // 显示图像
    cv::imshow("Ellipse", image);
    cv::waitKey(0);
    return 0;
}
```

### `cv::ellipse2Poly()` (将椭圆转换为多边形顶点坐标的函数)

`cv::ellipse2Poly()` 是 OpenCV 中用于将椭圆转换为多边形顶点坐标的函数。

```cpp
void cv::ellipse2Poly(
    Point center,
    Size axes,
    int angle,
    int arcStart,
    int arcEnd,
    int delta,
    std::vector<Point>& pts
);
```

- **Point center**: 椭圆的中心点坐标。
  - **说明**: 椭圆的中心点坐标 `(x, y)`。
- **Size axes**: 椭圆的半长轴和半短轴长度。
  - **说明**: 椭圆的半长轴和半短轴的长度 `(major axis length, minor axis length)`。
- **int angle**: 椭圆的旋转角度。
  - **说明**: 椭圆相对于水平轴的旋转角度。正值表示顺时针旋转。
- **int arcStart**: 弧的起始角度。
  - **说明**: 弧的起始角度，以度为单位。0 度表示水平向右。
- **int arcEnd**: 弧的结束角度。
  - **说明**: 弧的结束角度，以度为单位。360 度表示一个完整的椭圆。
- **int delta**: 角度增量。
  - **说明**: 角度增量，控制弧线细分的精度。通常设置为1。
- **`std::vector<Point>& pts`**: 输出的多边形顶点坐标。
  - **说明**: 存储多边形顶点坐标的向量。#
以下是一个**示例代码**，展示如何使用 `cv::ellipse2Poly()` 函数将椭圆转换为多边形顶点坐标，并绘制多边形：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 定义椭圆的参数
    cv::Point center(200, 200); // 中心点坐标
    cv::Size axes(100, 50);     // 半长轴和半短轴长度
    int angle = 30;             // 旋转角度
    int arcStart = 0;           // 弧的起始角度
    int arcEnd = 360;           // 弧的结束角度
    // 存储多边形顶点坐标的向量
    std::vector<cv::Point> pts;
    // 将椭圆转换为多边形顶点坐标
    cv::ellipse2Poly(center, axes, angle, arcStart, arcEnd, 1, pts);
    // 创建一个黑色图像
    cv::Mat image = cv::Mat::zeros(400, 400, CV_8UC3);
    // 绘制多边形
    cv::polylines(image, pts, true, cv::Scalar(0, 255, 0), 2);
    // 显示图像
    cv::imshow("Ellipse Polygon", image);
    cv::waitKey(0);
    return 0;
}
```

### `cv::rectangle()`(用于绘制矩形的函数)

**`cv::rectangle()`** 是 OpenCV 中用于绘制矩形的函数。

```cpp
void cv::rectangle(
    InputOutputArray img,
    Point pt1,
    Point pt2,
    const Scalar& color,
    int thickness = 1,
    int lineType = LINE_8,
    int shift = 0
);
```

- **InputOutputArray img**: 输入输出图像。
  - **说明**: 要在其上绘制矩形的图像。可以是单通道或多通道图像。
- **Point pt1, pt2**: 矩形的对角线顶点坐标。
  - **说明**: 矩形的对角线顶点坐标 `(x1, y1)` 和 `(x2, y2)`，其中 `(x1, y1)` 是左上角顶点，`(x2, y2)` 是右下角顶点。
- **const Scalar& color**: 矩形的颜色。
  - **说明**: 矩形的颜色，可以是单通道灰度值或多通道颜色值。
- **int thickness**: 矩形边界的厚度（可选）。
  - **默认值**: `1`。
  - **说明**: 矩形边界的像素宽度。如果为负值，如 `FILLED`，表示填充整个矩形。
- **int lineType**: 边界的类型（可选）。
  - **默认值**: `LINE_8`。
  - **说明**: 边界的线型，可以是 `LINE_4`、`LINE_8`、`LINE_AA`（抗锯齿线）等之一。
- **int shift**: 坐标点的小数部分位数（可选）。
  - **默认值**: `0`。
  - **说明**: 坐标点的小数部分位数位移量。
以下是一个**示例代码**，展示如何使用 `cv::rectangle()` 函数在图像上绘制一个蓝色的矩形：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 创建一个黑色图像
    cv::Mat image = cv::Mat::zeros(400, 400, CV_8UC3);
    // 定义矩形的对角线顶点坐标
    cv::Point pt1(100, 100); // 左上角顶点
    cv::Point pt2(300, 300); // 右下角顶点
    // 绘制蓝色的矩形
    cv::Scalar color(255, 0, 0); // 蓝色 BGR
    cv::rectangle(image, pt1, pt2, color, 2);
    // 显示图像
    cv::imshow("Rectangle", image);
    cv::waitKey(0);
    return 0;
}
```

### `cv::fillPoly()` (用于绘制并填充多边形的函数)

**`cv::fillPoly()`** 是 OpenCV 中用于绘制并填充多边形的函数。

```cpp
void cv::fillPoly(
    InputOutputArray img,
    const Point** pts,
    const int* npts,
    int ncontours,
    const Scalar& color,
    int lineType = LINE_8,
    int shift = 0,
    Point offset = Point()
);
```

- **InputOutputArray img**: 输入输出图像。
  - **说明**: 要在其上绘制和填充多边形的图像。可以是单通道或多通道图像。
- **const Point\*\* pts**: 多边形顶点的数组。
  - **说明**: 指向多边形顶点数组的指针，每个元素是指向 `cv::Point` 的指针，表示多边形的各个顶点。
- **const int\* npts**: 每个多边形的顶点数目数组。
  - **说明**: 指向整数数组的指针，每个元素表示相应多边形的顶点数目。
- **int ncontours**: 多边形的数量。
  - **说明**: 要绘制和填充的多边形的数量。
- **const Scalar& color**: 多边形的填充颜色。
  - **说明**: 多边形的填充颜色，可以是单通道灰度值或多通道颜色值。
- **int lineType**: 边界的类型（可选）。
  - **默认值**: `LINE_8`。
  - **说明**: 边界的线型，可以是 `LINE_4`、`LINE_8`、`LINE_AA`（抗锯齿线）等之一。
- **int shift**: 坐标点的小数部分位数（可选）。
  - **默认值**: `0`。
  - **说明**: 坐标点的小数部分位数位移量。
- **Point offset**: 偏移量（可选）。
  - **默认值**: `Point()`。
  - **说明**: 每个多边形顶点的偏移量。
以下是一个**示例代码**，展示如何使用 `cv::fillPoly()` 函数绘制和填充一个绿色的多边形：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 创建一个黑色图像
    cv::Mat image = cv::Mat::zeros(400, 400, CV_8UC3);
    // 定义多边形的顶点坐标
    cv::Point pts[1][4];
    pts[0][0] = cv::Point(100, 100);
    pts[0][1] = cv::Point(300, 100);
    pts[0][2] = cv::Point(300, 300);
    pts[0][3] = cv::Point(100, 300);
    const cv::Point* ppt[1] = { pts[0] };
    int npt[] = { 4 };
    // 绘制并填充绿色的多边形
    cv::Scalar color(0, 255, 0); // 绿色 BGR
    cv::fillPoly(image, ppt, npt, 1, color, 8);
    // 显示图像
    cv::imshow("Filled Polygon", image);
    cv::waitKey(0);
    return 0;
}
```

### `cv::putText()`(用于在图像上绘制文本的函数)

**`cv::putText()`** 是 OpenCV 中用于在图像上绘制文本的函数。

```cpp
void cv::putText(
    InputOutputArray img,
    const String& text,
    Point org,
    int fontFace,
    double fontScale,
    Scalar color,
    int thickness = 1,
    int lineType = LINE_8,
    bool bottomLeftOrigin = false
);
```

- **InputOutputArray img**: 输入输出图像。
  - **说明**: 要在其上绘制文本的图像。可以是单通道或多通道图像。
- **const String& text**: 要绘制的文本字符串。
  - **说明**: 要在图像上显示的文本内容。
- **Point org**: 文本的起始坐标位置。
  - **说明**: 文本在图像上的起始位置 `(x, y)`，左上角的坐标。
- **int fontFace**: 字体类型（可选）。
  - **默认值**: `FONT_HERSHEY_SIMPLEX`。
  - **说明**: 字体类型，可以是 `FONT_HERSHEY_SIMPLEX`、`FONT_HERSHEY_PLAIN` 等之一。
- **double fontScale**: 字体缩放因子。
  - **说明**: 字体大小的缩放因子。
- **Scalar color**: 文本的颜色。
  - **说明**: 文本的颜色，可以是单通道灰度值或多通道颜色值。
- **int thickness**: 文本的线条粗细（可选）。
  - **默认值**: `1`。
  - **说明**: 文本的线条粗细。
- **int lineType**: 文本的线条类型（可选）。
  - **默认值**: `LINE_8`。
  - **说明**: 文本的线条类型，可以是 `LINE_4`、`LINE_8`、`LINE_AA`（抗锯齿线）等之一。
- **bool bottomLeftOrigin**: 坐标系原点（可选）。
  - **默认值**: `false`。
  - **说明**: 如果为 `true`，则 `org` 参数表示文本框左下角的坐标，否则表示左上角的坐标。
以下是一个**示例代码**，展示如何使用 `cv::putText()` 函数在图像上绘制白色的文本：

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
int main() {
    // 创建一个黑色图像
    cv::Mat image = cv::Mat::zeros(400, 400, CV_8UC3);
    // 定义要显示的文本内容和起始坐标
    std::string text = "Hello, OpenCV!";
    cv::Point org(50, 200);
    // 设置字体、字体大小和颜色
    int fontFace = cv::FONT_HERSHEY_SIMPLEX;
    double fontScale = 1.5;
    cv::Scalar color(255, 255, 255); // 白色 BGR
    // 绘制文本
    cv::putText(image, text, org, fontFace, fontScale, color, 2);
    // 显示图像
    cv::imshow("Text on Image", image);
    cv::waitKey(0);
    return 0;
}
```
