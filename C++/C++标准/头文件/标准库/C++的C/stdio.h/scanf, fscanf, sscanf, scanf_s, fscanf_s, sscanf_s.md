---
tags:
  - CPP
---
# scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s

| **int scanf（ const char *格式， ...）;**                          | **(1)** | **（直到 C99）**  | 从标准输入（通常是键盘）读取格式化数据。                |
| ------------------------------------------------------------- | ------- | ------------- | ----------------------------------- |
| **int scanf（ const char *限制格式， ...）;**                        | **(1)** | **（自 C99 起）** | **从标准输入（通常是键盘）读取格式化数据。**            |
| **int fscanf（ FILE *stream， const char *format， ...）;**       | **(2)** | **（直到 C99）**  | **从文件中读取格式化数据。**                    |
| **int fscanf（ FILE *限制流， const char *限制格式， ...）;**            | **(2)** | **（自 C99 起）** | **从文件中读取格式化数据。**                    |
| **int sscanf（ const char *buffer， const char *format， ...）;** | **(3)** | **（直到 C99）**  | **从字符串中读取格式化数据。**                   |
| **int sscanf（ const char *限制缓冲区， const char *限制格式， ...）;**    | **(3)** | **（自 C99 起）** | **从字符串中读取格式化数据。**                   |
| **int scanf_s（const char *限制格式，...）;**                        | **(4)** | **（自 C11 起）** | **与 `scanf` 类似，但需要为每个字符串输入指定其大小。**  |
| **int fscanf_s（FILE *限制流，常量字符 *限制格式，...）;**                   | **(5)** | **（自 C11 起）** | **与 `fscanf` 类似，但需要为每个字符串输入指定其大小。** |
| **int sscanf_s（const char *限制缓冲区， const char *限制格式， ...）;**   | **(6)** | **（自 C11 起）** | **与 `sscanf` 类似，但需要为每个字符串输入指定其大小。** |

与所有边界检查函数一样，仅当实现定义了 __STDC_LIB_EXT1__ 并且用户在包含 <stdio.h> 之前将 __STDC_WANT_LIB_EXT1__ 定义为整数常量 1 时，scanf_s、fscanf_s 和 sscanf_s 才保证可用。

- **建议：**
    - 使用 `if` 语句判断返回值，确保数据成功读取。
    - 使用 `clearerr(stdin)` 和 `rewind(stdin)` 清除错误状态并重置输入流。

### 个别用法

#### 1. `fscanf`

```C++
FILE *file = fopen("data.txt", "r");
int a; float b; char str[50]; 
fscanf(file, "%d %f %s", &a, &b, str); 
fclose(file);
```

### 2. `sscanf`

```C++
char input[] = "123 45.67 example"; int a; float b; char str[50]; 
sscanf(input, "%d %f %s", &a, &b, str); 
printf("From string: %d, %f, %s\n", a, b, str);
```

#### 3. `scanf_s`

```C++
int a; float b; char str[50]; unsigned int str_size = sizeof(str);
scanf_s("%d %f %s", &a, &b, str, str_size); 
printf("You entered: %d, %f, %s\n", a, b, str);
```

#### 4. `fscanf_s`

```C++
FILE *file = fopen("data.txt", "r"); int a; float b; char str[50]; unsigned int str_size = sizeof(str); 
fscanf_s(file, "%d %f %s", &a, &b, str, str_size); 
fclose(file); 
printf("From file: %d, %f, %s\n", a, b, str);
```

#### 5. `sscanf_s`

```C++
char input[] = "123 45.67 example"; int a; float b; char str[50]; 
unsigned int str_size = sizeof(str); 
sscanf_s(input, "%d %f %s", &a, &b, str, str_size); 
printf("From string: %d, %f, %s\n", a, b, str);
```

### 参数

| **流**   | **-** | **输入要从中读取的文件流**                 |
| ------- | ----- | ------------------------------- |
| **缓冲区** | **-** | **指向要从中读取的以 null 结尾的字符串的指针**    |
| **格式**  | **-** | **指向以 null 结尾的字符串的指针，指定如何读取输入** |
| **...** | **-** | **接收参数。**                       |

可以使用以下格式说明符：

| **转换  <br>说明符**            | **解释**                                                                                                                                                                                                                               |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`c`**                    | **匹配一个字符或一系列字符。如果使用宽度说明符，则与_宽度_字符完全匹配（参数必须是指向具有足够空间的数组的指针）。与 `%s` 和 `%[` 不同，不会将 null 字符追加到数组中。**                                                                                                                                     |
| **`s`**                    | **匹配非空格字符序列（字符串）。<br>如果使用宽度说明符，则匹配到_宽度_或直到第一个空格字符，以先出现者为准。除了匹配的字符外，始终存储一个 null 字符（因此参数数组必须至少有_宽度 + 1_ 个字符的空间）**                                                                                                                      |
| **`[set]`**                | **匹配字符集中的非空字符序列。<br>如果集合的第一个字符是 ，则集合中未匹配的所有字符。如果集合以 或 开头，则角色也包含在集合中。它是实现定义的，扫描集中非初始位置的字符是否可以指示范围，如 中所示。如果使用 width 说明符，则仅匹配到_宽度_。除了匹配的字符外，始终存储一个 null 字符（因此参数数组必须至少有_宽度 + 1_ 个字符的空间）`**^**``**]**``**^]**``**]**``**-**``**[0-9]**`** |
| **`d`**                    | **匹配十进制整数。**                                                                                                                                                                                                                         |
| **`i`**                    | **匹配整数。注意该转换符可以匹配二进制、八进制、十进制、十六进制的整数。**                                                                                                                                                                                              |
| **`u`**                    | **匹配无符号十进制整数。**                                                                                                                                                                                                                      |
| **`o`**                    | **匹配无符号八进制整数。**                                                                                                                                                                                                                      |
| **`x`,`X`**                | **匹配无符号的十六进制整数。**                                                                                                                                                                                                                    |
| **`n`**                    | **返回到目前为止读取的字符数。不消耗任何输入。不递增分配计数。如果说明符定义了赋值抑制运算符，则该行为是未定义的**                                                                                                                                                                          |
| **`a,A,e,E,f,F,g,G`** <br> | **匹配浮点数。**                                                                                                                                                                                                                           |
| **`p`**                    | **匹配定义指针的实现定义的字符序列。`printf`函数系列应使用格式说明符生成相同的序列`%p`**                                                                                                                                                                                 |

### 特殊转换符介绍

#### 1. `%i`

```C++
int i;
scanf("%i",&i);
printf("%i",i);
```

**注意：`%i`当输入十进制时，输出为十进制，输入为为八进制时，输出为八进制依次类推。**

#### 2. `%n`

```C++
int a,b,n;
scanf("%d%d%n",&a,&b,&n);
printf("%d,%d\n",a,b);
printf("Number of characters read: %d\n", n);
```

**注意：`%n` 是一个特殊的格式说明符，用于 `scanf` 函数中，表示到目前为止已经读取的字符数。`%n` 不会消耗任何输入，也不会将输入中的字符转换为值，而是将已经处理的字符数存储到相应的指针变量中。**
**当我输入`65 65`时，最后输出的n为5，即`6 5 空格 6 5`五位**

#### 3. `a,A,e,E,f,F,g,G`

```C++
float a,e,f,g;
scanf("%a%e%f%g",&a,&e,&f,&g);   //3.22 3.22 3.22 3.22
printf("%a,%e,%f,%g\n",a,e,f,g);  //0xc.e147bp-2,3.220000e+00,3.220000,3.22
```

- `%a`: 读取浮点数，并以十六进制浮点数格式存储在`a`中。
- `%e`: 读取浮点数，并以科学计数法格式存储在`e`中。
- `%f`: 读取浮点数，并以小数点格式存储在`f`中。
- `%g`: 读取浮点数，并以自动选择最合适的格式（科学计数法或小数点格式）存储在`g`中。
**注意：`%a`：这是 C99 标准引入的，用于打印和读取十六进制浮点数**

### 复杂性

不保证。值得注意的是，一些实现是 O（N），其中`sscanf`N = strlen（缓冲区）。

### 笔记

由于大多数转换说明符首先使用所有连续的空格，因此诸如

```C++
scanf("%d", &a);
scanf("%d", &b);
```

将读取在不同行上输入的两个整数（秒%d将使用第一个剩余的换行符）或在同一行上，用空格或制表符分隔（第二个%d将占用空格或制表符）。

#### 1. scanf不读取空格

```C++
scanf("%d",&n);
scanf("%c",&b);
printf("%d",n);
printf("%c",b);
```

像以上程序，当输入`2回车`时，整形n接受2，字符型b接受回车符。当输入`2ff`时，整形n接受2，字符型b接受f。
