---
tags:
  - CPP
---

# 复制消除

**省略复制及移动 (C++11 起)构造函数，导致零复制的按值传递语义。**

### 解释

#### 强制的复制/移动操作消除

下列环境下，要求编译器省略类对象的复制和移动构造，即使复制/移动构造函数和析构函数拥有可观察副作用。直接将对象构造到它们本来要复制/移动到的存储中。复制/移动构造函数不必存在或可访问：

- 在 [[return 语句|return 语句]]中，当操作数为与函数返回类型为同一类类型的[[值类别|纯右值]]（忽略[[cv（const 与 volatile）类型限定符|cv 限定]]时：

```c++
T f() {
    return T();
}
 
f(); // 仅调用一次 T 的默认构造函数
```

**返回类型的析构函数必须在 return 语句位置可访问且未被删除，即使无待销毁的 T 对象。**

> **函数返回临时对象时**： 如果函数的返回类型与返回表达式的类型一致，并且返回表达式是一个右值（即临时对象），编译器可以直接在返回对象的存储位置上构造这个对象，而不是构造一个临时对象然后再复制或移动到返回值。

- 在对象的初始化中，当初始化器表达式为与变量类型为同一类类型的[[值类别|纯右值]]（忽略[[cv（const 与 volatile）类型限定符|cv 限定]]）时：

```c++
T x = T(T(f())); // 仅调用一次 T 的默认构造函数以初始化 x
```

这仅能在已知待初始化对象不是潜在重叠的子对象时应用：

> **初始化对象时**： 当我们使用右值直接初始化一个对象，并且这个右值的类型与变量类型一致时，编译器可以省略临时对象的复制或移动。
> 即使看似构造了多个临时对象（`T(f())`，`T(T(f()))`），编译器会直接在 `x` 的存储位置上构造一次 `T`，避免不必要的中间步骤。

```c++
struct C { /* ... */ };
C f();
struct D;
D g();
struct D : C {
    D() : C(f()) { }    // 初始化基类子对象时无消除
    D(int) : D(g()) { } // 无消除，因为正在初始化的 D 对象可能为某个其他类的基类子对象
};
```

==**注意**==：上述规则并不指定优化：针对[[值类别|纯右值]]和[[隐式转换|临时量]]的 C++17 核心语言规定本质上不同于之前的 C++ 版本：不再有用以复制/移动的临时量。描述 C++17 语义的另一种方式是“传递未实质化的值”：返回并使用纯右值时不实质化临时量。

>临时量消除有一些限制，主要包括**对象的潜在重叠子对象**。简单来说，如果一个对象在继承链或复杂的构造函数初始化中，有潜在重叠的部分（比如基类对象或者成员对象），那么复制/移动省略可能不会发生

#### 非强制的复制/移动 (C++11 起)操作消除

下列环境下，容许但不要求编译器省略类对象的复制和移动 (C++11 起)构造，即使复制/移动 (C++11 起)构造函数和析构函数拥有可观察副作用。直接将对象构造到它们本来要复制/移动到的存储中。这是一项优化：**即使进行了优化而不调用复制/移动 (C++11 起)构造函数，它仍然必须存在且可访问（如同完全未发生优化），否则程序非良构**：

- [[return 语句|return 语句]]中，当操作数是拥有自动存储期的非 `volatile` 对象的名字，其并非函数形参或 `catch` 子句形参，且其具有与函数返回类型相同的类类型（忽略[[cv（const 与 volatile）类型限定符|cv 限定]]）时。这种复制消除的变体被称为 NRVO，“具名返回值优化 (named return value optimization)”。
- 在对象的初始化中，当源对象是无名临时量且与目标对象具有相同类型（忽略[[cv（const 与 volatile）类型限定符|cv 限定]]）时。当无名临时量为 return 语句的操作数时，称这种复制消除的变体为 RVO，“返回值优化 (return value optimization)”。(C++17 前)
	返回值优化是强制要求的，而不再被当做复制消除；
- - [[throw 表达式|throw 表达式]]中，**当操作数是具有自动存储期的非 volatile 对象的名字，其并非函数形参或 catch 子句形参，且其作用域不延伸超过最内层的 try 块（若有 try 块）时**。
- [[try 块|catch 子句]]中，**当实参与抛出的异常对象具有相同类型（忽略[[cv（const 与 volatile）类型限定符|cv 限定]]）时，省略异常对象的复制**，而该 catch 子句体直接访问该异常对象，如同按引用捕获它一样（不可能从异常对象移动，因为它始终是左值）。如果这种复制消除会因为除了跳过该 `catch` 子句形参的复制构造函数和析构函数之外的任何原因，导致程序的可观察行为发生改变，则它被禁止（例如，当修改了 `catch` 子句的实参，并以 `throw` 重新抛出异常对象时）。(C++11 起)
- - 在[[协程 (C++20)|协程]]中，**可以消除将形参向协程状态内的复制/移动，只要除了对形参的构造函数与析构函数的调用被忽略以外，不改变程序的行为即可**。若在暂停点后始终不使用形参，或者整个协程状态本就始终不在堆上分配，则可出现此情形。(C++20 起)
进行复制消除时，实现将被省略的复制/移动 (C++11 起)操作的源和目标，单纯地当做指代同一对象的两种不同方式，而该对象的销毁，发生于假如不进行优化时两个对象本应被析构的时机的较迟者（**但若被选择的构造函数的形参是对象类型的右值引用，则其销毁发生于目标对象本应被销毁时**） (C++17 起)。

可以连锁多次复制消除，以消除多次复制。

- 在[[常量表达式|常量表达式]]和[[常量初始化|常量初始化]]中，保证进行返回值优化（RVO），但禁止具名返回值优化（NRVO）：

```c++
struct A {
    void *p;
    constexpr A(): p(this) {}
};
 
constexpr A g()
{
    A a;
    return a;
}
 
constexpr A a;          // a.p 指向 a
// constexpr A b = g(); // 错误： b.p 会悬垂，并会指向有自动存储期的临时量
 
void h()
{
    A c = g();          // c.p 可能指向 c 或转瞬即逝的临时量
}
 
extern const A d; 
constexpr A f()
{
    A e;
    if (&e == &d)
        return A();
    else
        return e;
    // 在常量求值中强制 NRVO 会导致矛盾，即当且仅当不执行 NRVO 时执行 NRVO
} 
// constexpr A d = f(); // 错误： d.p 悬垂
```

### 注解

复制消除是允许改变可观察副作用的唯一得到允许的优化形式 (C++14 前)两种允许的优化形式之一，另一种是[[new 表达式#分配|分配消除与扩展]] (C++14 起)。因为一些编译器并不在所有允许的场合中进行复制消除（例如 `debug` 模式下），依赖于复制/移动构造函数和析构函数的副作用的程序是不可移植的。

在 `return` 语句或 `throw` 表达式中，若编译器不能进行复制消除，但满足或本应满足复制消除的条件（不含源是函数形参的情况），即使对象由左值代表，编译器也将尝试使用移动构造函数；细节见 [[return 语句|return 语句]]。(C++11 起)。

---
#未完成 