---
tags:
  - CPP
---

# 位域

**声明具有以位为单位的明确大小的类数据成员**。相邻的位域成员可以打包成共享和跨过各个字节。

**位域声明**是使用下列声明符的[[非静态数据成员|类数据成员声明]]：
- `标识符(可选) attr(可选) `:` 大小`
- `标识符(可选) attr(可选) `:` 大小 花括号或等号初始化器`(C++20 起)

位域的_类型_由[[声明|声明语法]]的 声明说明符序列 引入.

- `attr(C++11)` - 可选的任何数量[[属性说明符序列(C++11 起)|属性]]的序列
- 标识符 - 被声明的位域名。名字是可选的：无名位域引入指定数量的填充位
- 大小 - 值大于或等于零的[[常量表达式|整型常量表达式]]。大于零时，这是位域将占有的位数。值零仅对无名位域允许使用并具有特殊含义：它指定类定义中的下个位域将始于分配单元的边界。
- 花括号或等号初始化器 - 此位域所使用的[[非静态数据成员]]

---

> **笔记**
> **==请主要查看以下代码==**

```c++
#include <iostream>
using namespace std;
class MyClass1
{
public:
    int x : 8;
    int y : 8;
    int z : 16;
};
class MyClass2
{
public:
    int x : 8;
    int y : 8;
    int z : 17;
};
class MyClass3
{
public:
    char x : 4;
    int y : 8;
    int z : 16;
};
int main()
{
    cout << "sizeof(MyClass1): " << sizeof(MyClass1) << endl;  //4 
    cout << "sizeof(MyClass2): " << sizeof(MyClass2) << endl;  //8
    cout << "sizeof(MyClass3): " << sizeof(MyClass3) << endl;  //8
    return 0;
}
```

> [!NOTE] **解释**
> 1. 在`MyClass1`和`MyClass2`中分别定义了三个`int`类型的变量，其中，由于对齐原则每行各为4字节，`x`占用8位，`y`占用8位，`z`占用16位，刚好把第一个`int`类型的32位占用完。
> 2. 在第二个类中，`z`占用了17位，导致超出了第一个`int`的32位的大小，所以又占用了`y`的32位`int`大小，又占用了4字节，最终8字节。
> 3. 第三个类中，由于字节对齐，所以`char`类型被对齐到4字节，后面的 3 字节用于对齐，使 `int y` 从 4 字节边界开始，所以实际只有1字节，占用完后，继续占用`y`的4字节，导致占用8字节。

---

### 解释

**位域中的位数设置其所能保有的值的极限**：

```c++
#include <iostream>
struct S {
 // 三位的无符号位域，
 // 允许值为 0...7
 unsigned int b : 3;
};
int main()
{
    S s = {6};
    ++s.b; // 在位域中存储值 7
    std::cout << s.b << '\n';
    ++s.b; // 值 8 不适合此位域
    std::cout << s.b << '\n'; // 正式来说是由实现定义的行为，通常为 0
}
```

可能的输出：

```c++
7
0
```

**多个相邻位域通常打包在一起**（尽管此行为是实现定义的）：

运行此代码:

```c++
#include <iostream>
struct S {
    // 将通常占用 2 字节：
    // 3 位：b1 的值
    // 2 位：不使用
    // 6 位：b2 的值
    // 2 位：b3 的值
    // 3 位：不使用
    unsigned char b1 : 3, : 2, b2 : 6, b3 : 2;
};
int main()
{
    std::cout << sizeof(S) << '\n'; // 通常打印 2
}
```

可能的输出：

```c++
2
```

**特殊的零大小无名位域可用于强行打破填充**。它指定下个位域始于其分配单元的开始：

```c++
#include <iostream>
struct S {
    // 通常将占用 2 字节：
    // 3 位：b1 的值
    // 5 位：不使用
    // 6 位：b2 的值
    // 2 位：b3 的值
    unsigned char b1 : 3;
    unsigned char :0; // 开始新字节
    unsigned char b2 : 6;
    unsigned char b3 : 2;
};
int main()
{
    std::cout << sizeof(S) << '\n'; // 通常打印 2
}```
可能的输出：

```c++
2
```

若位域所指定的大小大于其类型的大小，则值由类型所限制：[std::uint8_t](https://www.apiref.com/cpp-zh/cpp/types/integer.html) b : 1000; 仍会保有 0 与 255 间的值。额外位成为不使用的填充位。

因为位域不必然始于一个字节的开始，故不能取位域的地址。指向位域的指针和非 const 引用是不可行的。从位域[[引用初始化|初始化 const 引用]]时，将创建一个临时量（其类型是位域的类型），并以该位域的值复制初始化，而引用绑定到该临时量。

位域的类型只能是整型或枚举类型。

位域不能是[[static 成员|静态数据成员]]。

没有位域[[值类别|纯右值]]：左值到右值转换始终生成位域底层类型的对象。

---

位域无[[非静态数据成员|默认成员初始化器]]：int b : 1 = 0; 与 int b : 1 {0} 非良构。

在位域大小与默认初始化器有歧义的情况下，选择组成合法大小的最长记号序列：

```c++
int a;
  const int b = 0;
  struct S {
    // 简单情况
    int x1 : 8 = 42;               // OK；"= 42" 是 花括号或等号初始化器
    int x2 : 8 { 42 };             // OK；"{ 42 }" 是 花括号或等号初始化器
    // 歧义
    int y1 : true ? 8 : a = 42;    // OK；不存在 花括号或等号初始化器
    int y2 : true ? 8 : b = 42;    // 错误：不能赋值给 const int
    int y3 : (true ? 8 : b) = 42;  // OK；"= 42" 是 花括号或等号初始化器
    int z : 1 || new int { 0 };    // OK；不存在 花括号或等号初始化器
  };
```

### 注解

位域的下列性质_由实现定义_

- 以范围外的值对有符号位域进行赋值或初始化，或对有符号位域进行自增越过其范围，所产生的值。
- 任何关于类对象中位域的实际分配细节

- 例如，在某些平台上，位域不跨过字节，其他平台上会跨过
- 还有，在某些平台上，位域从左到右打包，其他为从右到左
---

- - 未显式标为 signed 或 unsigned 的 char、short、int、long 及 long long 位域是有符号还是无符号。

- 例如，int b:3; 可能有值域 0..7 或 -4..3。
在 C 编程语言中，位域的宽度不能超过底层类型的宽度。
