---
tags:
  - CPP
---

# 位域

**声明具有以位为单位的明确大小的类数据成员**。相邻的位域成员可以打包成共享和跨过各个字节。

**位域声明**是使用下列声明符的[[非静态数据成员|类数据成员声明]]：
- `标识符(可选) attr(可选) `:` 大小`
- `标识符(可选) attr(可选) `:` 大小 花括号或等号初始化器`(C++20 起)

位域的_类型_由[[声明|声明语法]]的 声明说明符序列 引入.

- `attr(C++11)` - 可选的任何数量[[属性说明符序列(C++11 起)|属性]]的序列
- 标识符 - 被声明的位域名。名字是可选的：无名位域引入指定数量的填充位
- 大小 - 值大于或等于零的[[常量表达式|整型常量表达式]]。大于零时，这是位域将占有的位数。值零仅对无名位域允许使用并具有特殊含义：它指定类定义中的下个位域将始于分配单元的边界。
- 花括号或等号初始化器 - 此位域所使用的[[非静态数据成员]]

### 解释

位域中的位数设置其所能保有的值的极限：

```c++
#include <iostream>
struct S {
 // 三位的无符号位域，
 // 允许值为 0...7
 unsigned int b : 3;
};
int main()
{
    S s = {6};
    ++s.b; // 在位域中存储值 7
    std::cout << s.b << '\n';
    ++s.b; // 值 8 不适合此位域
    std::cout << s.b << '\n'; // 正式来说是由实现定义的行为，通常为 0
}
```

可能的输出：

```c++
7
0
```

**多个相邻位域通常打包在一起**（尽管此行为是实现定义的）：

运行此代码:

```c++
#include <iostream>
struct S {
    // 将通常占用 2 字节：
    // 3 位：b1 的值
    // 2 位：不使用
    // 6 位：b2 的值
    // 2 位：b3 的值
    // 3 位：不使用
    unsigned char b1 : 3, : 2, b2 : 6, b3 : 2;
};
int main()
{
    std::cout << sizeof(S) << '\n'; // 通常打印 2
}
```

可能的输出：

```c++
2
```

**特殊的零大小无名位域可用于强行打破填充**。它指定下个位域始于其分配单元的开始：

```c++
#include <iostream>
struct S {
    // 通常将占用 2 字节：
    // 3 位：b1 的值
    // 5 位：不使用
    // 6 位：b2 的值
    // 2 位：b3 的值
    unsigned char b1 : 3;
    unsigned char :0; // 开始新字节
    unsigned char b2 : 6;
    unsigned char b3 : 2;
};
int main()
{
    std::cout << sizeof(S) << '\n'; // 通常打印 2
}```
可能的输出：

```c++
2
```

若位域所指定的大小大于其类型的大小，则值由类型所限制：[std::uint8_t](https://www.apiref.com/cpp-zh/cpp/types/integer.html) b : 1000; 仍会保有 0 与 255 间的值。额外位成为不使用的填充位。

因为位域不必然始于一个字节的开始，故不能取位域的地址。指向位域的指针和非 const 引用是不可行的。从位域[[引用初始化|初始化 const 引用]]时，将创建一个临时量（其类型是位域的类型），并以该位域的值复制初始化，而引用绑定到该临时量。

位域的类型只能是整型或枚举类型。

位域不能是[[static 成员|静态数据成员]]。

没有位域[[值类别|纯右值]]：左值到右值转换始终生成位域底层类型的对象。
