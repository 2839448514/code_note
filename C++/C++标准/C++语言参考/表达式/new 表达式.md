---
tags:
  - CPP
---

# new 表达式

创建并初始化拥有动态[[存储类说明符|存储期]]的对象，这些对象的生存期不受它们创建时所在的作用域限制。

### 语法

- `::`(可选) `new` (布置参数)(可选) ( 类型 ) 初始化器(可选)
- `::`(可选) `new` (布置参数)(可选) 类型 初始化器(可选)

1) 尝试创建[[类型|类型标识]]类型 所指代的类型的一个对象，它可以是数组类型，可以包含[[占位符类型说明符 (C++11 起)|占位符类型说明符]] (C++11 起)，或包含将由[[类模板实参推导 (CTAD)(C++17 起)|类模板实参推导]]推出的类模板名 (C++17 起)。

2) 同上，但 类型 不能包含括号：

```c++
new int(*[10])(); // 错误：分析成 (new int) (*[10]) ()  
new (int (*[10])()); // OK：分配 10 个函数指针的数组
```

**另外，无括号的 类型 是贪心的**：它将包含可以是声明符一部分的所有记号：

```c++
new int + 1; // OK：分析成 (new int) + 1，增加 new int 所返回的指针  
new int * 1; // 错误：分析成 (new int*) (1)
```

符合下列条件之一时 初始化器 不是可选的（即不可缺的）

- 类型 中使用了占位符（`auto` 或 `decltype(auto)` (C++14 起)）
- 类型 是[[数组声明|未知边界数组]]

```c++
auto p = new auto('c');          // 创建单个 char 类型的对象。p 是一个 char*  
double* p = new double[]{1,2,3}; // 创建 double[3] 类型的数组
```

### 解释

`new` 表达式尝试申请存储空间，并在已申请的存储空间上，尝试构造并初始化为一个无名对象，或无名对象的数组。**new表达式返回一个指向所构造的对象或者对象数组的==纯右值指针==。**

若 类型 是**数组类型**，则其第一维之外的所有维都必须指定为正的 [std::size_t] 类型[[常量表达式|整数常量表达式]] (C++14 前)，或[[常量表达式|经转换的常量表达式]]C++14 起)，但（仅当使用无括号语法 (2) ）第一维可以是整数类型、枚举类型或拥有单个到整数或枚举类型的非 `explicit` 转换函数的类类型 (C++14 前)任何能转换成 [std::size_t] 的表达式 (C++14 起)。这是直接创建大小在运行时定义的数组的唯一方法，这种数组常被称作_动态数组_：

```c++
int n = 42;
double a[n][5]; // 错误
auto p1 = new double[n][5];   // OK
auto p2 = new double[5][n];   // 错误：仅第一维可为非常量
auto p3 = new (double[n][5]); // 错误：语法 (1) 不能用于动态数组
```

> [!NOTE] `New`  
> `new` 可以用于动态创建大小在运行时确定的数组，这种数组被称为**动态数组**。但是在 C++ 中，只有**数组的第一维**可以是动态的（即大小可以在运行时确定），而其余的维度必须是编译时常量。

**若第一维中的值（若需要则转换到整数或枚举类型）为负，则行为未定义。**

### (C++11 前)

下列情况中指定第一维的表达式是错误的：

- 表达式是非类类型，且其值在转换到 `std::size_t` 前是负的；
- 表达式拥有类类型，且其值在用户定义转换函数后，在第二次标准转换前是负的；
- 表达式的值大于某个实现定义极限；
- 其值小于花括号初始化器中提供的数组元素数量（也包含字符串字面量中的终止 `'\0'`）。

#### 如果第一维值因以上任何原因而错误：

- 若在转换到 `std::size_t` 后，第一维是核心常量表达式，则程序**非良构**（引发编译时错误）；
- 否则，若要调用的分配函数是不抛出的，则 `new` 表达式返回请求结果类型的**空指针**；
- 否则，`new` 表达式不调用分配函数，而代之以抛出 `std::bad_array_new_length` 类型或其派生类的异常。

---

### (C++11 起)

第一维为零是可接受的，分配函数也会得到调用。

**注意：** `std::vector` 提供了与一维的动态数组类似的功能。

---

### 分配

`new` 表达式通过调用适当的**分配函数**分配存储。若 **类型** 是非数组类型，则函数名是 `operator new`。若 **类型** 是数组类型，则函数名是 `operator new[]`。

- 如分配函数中所描述，C++ 程序可提供这些函数的全局和类特有替换函数。若 `new` 表达式以可选的 `::` 运算符开始，如 `::new T` 或 `::new T[n]`，则忽略类特有替换函数（在全局作用域中查找函数）。否则，若 `T` 是类类型，则从 `T` 的类作用域中开始查找。
    
- **在调用分配函数时，`new` 表达式将请求的字节数作为 `std::size_t` 类型的第一参数传递给它，该参数对于非数组 `T` 精确地为 `sizeof(T)`。**
    
- **数组的分配** 中可能带有一个未指明的**开销**（overhead），且两次调用 `new` 的这个开销可能不同，除非选择的分配函数是标准非分配形式。`new` 表达式所返回的指针等于分配函数所返回的指针加上该值。许多实现使用数组开销存储数组中的对象数量，它为 `delete[]` 表达式所用，以进行正确数量的析构函数调用。
    
- 另外，若 `new` 被用于分配 `char`、`unsigned char` 或 `std::byte` 的数组，则它可能从分配函数请求额外内存，以此保证所有不大于请求数组大小的类型的对象，当将其放入所分配的数组中时能够正确对齐。

#### 优化

允许将各个 `new` 表达式通过可替换分配函数所进行的**分配予以省略或合并**。在省略的情况下，存储可以由编译器提供，而无需调用分配函数（这亦允许优化掉不使用的 `new` 表达式）。在合并的情况下，以下所有条件均为真时，`new` 表达式 `E1` 所做的分配可以被扩展，以提供另一个 `new` 表达式 `E2` 的额外存储：

1. `E1` 所分配对象的**生存期**严格包含 `E2` 所分配对象的生存期。
2. `E1` 与 `E2` 将调用同一可替换全局分配函数。
3. 对于抛出异常的分配函数，`E1` 与 `E2` 中的异常将首先被同一处理块捕捉。

**注意：** 此优化仅在使用 `new` 表达式时允许，而非调用可替换分配函数的任何其他方法：

- `delete [] new int[10];` 能被优化掉，但 `operator delete(operator new(10));` 不能。

#### (C++14 起)

在常量表达式求值期间，始终省略对分配函数的调用。只有在其他情况下调用可替换全局分配函数的 `new` 表达式能在常量表达式中求值。

### 布置 new

若提供了**布置参数**，则将它们作为额外实参传递给分配函数。这些分配函数被称作“**布置 new**”，这来源于标准分配函数 `void* operator new(std::size_t, void*)`，它直接返回未更改的第二实参。它被用于在已分配的存储中构造对象：

```c++
char* ptr = new char[sizeof(T)]; // 分配内存
T* tptr = new(ptr) T;            // 在已分配存储中构造（“布置”）
tptr->~T();                      // 销毁
delete[] ptr;                    // 解分配内存
```

**注意**：分配器 (`Allocator`) 类的各成员函数封装了此功能。

在分配具有超出 `__STDCPP_DEFAULT_NEW_ALIGNMENT__` 的对齐要求的对象或这种对象的数组时，`new` 表达式将**对齐要求**作为第二实参（以 `std::align_val_t` 包装）传递给分配函数。对于布置形式，`Template:expr` 被放在对齐之后，作为第三、第四个实参等。

若重载决议失败（当定义了具有不同签名的类特有分配函数时，会发生此种情况，因为它隐藏了全局版本），则以实参列表中不带对齐再次尝试进行重载决议。这允许不关心对齐的类特有分配函数优先于全局的关心对齐的分配函数。

#### (C++17 起)

cpp

复制代码

```c++
new T;      // 调用 operator new(sizeof(T))
// (C++17) 或 operator new(sizeof(T), std::align_val_t(alignof(T)))
new T[5];   // 调用 operator new[](sizeof(T)*5 + overhead)
// (C++17) 或 operator new(sizeof(T)*5 + overhead, std::align_val_t(alignof(T)))
new(2,f) T; // 调用 operator new(sizeof(T), 2, f)
// (C++17) 或 operator new(sizeof(T), std::align_val_t(alignof(T)), 2, f)
```

如果分配函数返回了**空指针**（这在重载决议选中的是无抛出的重载时可能发生，比如 `new(std::nothrow) T;`），则 `new` 表达式立即返回，而不会试图初始化对象或调用解分配函数。如果标准布置分配函数返回了空指针，则行为未定义，这在用户将空指针作为实参传递给它时可能发生。

### 构造

`new` 表达式所创建的对象按照下列规则**初始化**：

- 对于非数组的 **类型**，在所得内存区域中构造单个对象。
    - 若无**初始化器**，则对象被**默认初始化**。
    - 若**初始化器**是带括号的实参列表，则对象被**直接初始化**。
    - 若**初始化器**是花括号包围的实参列表，则对象被**列表初始化**。

#### (C++11 起)

- 若 **类型** 是数组类型，则初始化一个数组的对象。
    - 若无**初始化器**，则每个元素被**默认初始化**。
    - 若**初始化器**是一对空括号，则每个元素被**值初始化**。
    - 若**初始化器**是花括号包围的实参列表，则数组被**聚合初始化**。

#### (C++20 起)

- 若**初始化器**是带括号的实参列表，则数组被**聚合初始化**。

### 异常处理

如果初始化因抛出异常而终止（例如来自构造函数），则若 `new` 表达式已经分配了任何存储，则它将调用适当的**解分配函数**：

- 对于非数组**类型**为 `operator delete`，对于数组**类型**则为 `operator delete[]`。
- 若 `new` 表达式使用 `::new` 语法，则在全局作用域查找解分配函数，否则若 `T` 是类类型，则在 `T` 的作用域查找。
- 对于失败的布置 `new`，与之匹配的解分配函数中除第一个外的所有形参的类型，必须与布置 `new` 的各形参类型相同。

若找不到解分配函数，则不解分配内存。

### 内存泄漏

`new` 表达式所创建的对象（拥有**动态存储期**的对象），持续到将 `new` 表达式所返回的指针用于匹配的 `delete` 表达式之时。若指针的原值丢失，则对象变为不可达且无法解分配，即发生**内存泄漏**（memory leak）。

内存泄漏可能发生在以下情况：

```c++
int* p = new int(7); // 动态分配的 int 带值 7 p = nullptr; // 内存泄漏
```

或者指针离开作用域：

```c++
void f() {     int* p = new int(7); } // 内存泄漏
```

或者因为异常：

```c++
void f() {    
	int* p = new int(7);    
	g();      // 可能抛出异常    
	delete p; // 若无异常则 ok 
} // 若 g() 抛出异常则内存泄漏
```

为简化动态分配的对象管理，通常将 `new` 表达式的结果存储于**智能指针**中，例如：

- `std::auto_ptr` (C++17 前)
- `std::unique_ptr` 或 `std::shared_ptr` (C++11 起)

这些指针能够在上述情形中自动执行 `delete` 表达式，避免内存泄漏。
