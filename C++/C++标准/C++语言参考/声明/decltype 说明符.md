---
tags:
  - CPP
---

# decltype 说明符

检查实体的声明类型，或表达式的类型和值类别。

### 语法

`decltype ( 实体 )`(C++11 起)

`decltype ( 表达式 )`(C++11 起)

### 解释

1) 若实参为无括号的[[标识符|标识表达式]]或无括号的[[成员访问运算符|类成员访问]]表达式，则 `decltype` 产生以此表达式命名的实体的类型。若无这种实体，或该实参指名某个重载函数，则程序非良构。
	若实参是指名某个[[结构化绑定声明 (C++17 起)|结构化绑定]]的无括号的[[标识符|标识表达式]]，则 `decltype` 产生_被引用类型_（在关于结构化绑定声明的说明中有所描述）。(C++17 起)
	若实参是指名某个[[模板形参与模板实参|非类型模板形参]]的无括号的[[标识符|标识表达式]]，则 `decltype` 生成该模板形参的类型（当该模板形参以占位符类型声明时，则为进行任何所需的类型推导后的类型）。(C++20 起)

2) 若实参是其他类型为 `T` 的任何表达式，且
	a) 若 表达式 的[[值类别|值类别]]为_亡值_，则 `decltype` 产生 `T&&`；
	b) 若 表达式 的值类别为_左值_，则 `decltype` 产生 `T&`；
	c) 若 表达式 的值类别为_纯右值_，则 `decltype` 产生 `T`。
	**若 表达式 是返回类类型纯右值的函数调用**，或是右操作数为这种函数调用的[[其他运算符|逗号表达式]]，则不对该纯右值引入临时量。(C++17 前)
	**若 表达式 是除了（可带括号的）[[consteval 说明符 (C++20 起)|立即调用]]以外的 (C++20 起)纯右值**，则不从该纯右值[[隐式转换|实质化]]临时对象：这种纯右值无结果对象。(C++17 起)
	**不需要该类型[[类型|完整]]或拥有可用的[[析构函数|析构函数]]，而且类型可以是[[抽象类|抽象的]]**。此规则不适用于其子表达式：`decltype(f(g())) `中，`g() `必须有完整类型，但`f() `不必。
	**注意如果对象的名字带有括号，则它被当做通常的左值表达式**，从而 `decltype(x)` 和 `decltype((x))` 通常是不同的类型。

在难以或不可能以标准写法进行声明的类型时，`decltype` 很有用，例如 `lambda` 相关类型或依赖于模板形参的类型。

### 示例

```c++
#include <iostream>
 
struct A { double x; };
const A* a;
 
decltype(a->x) y;       // y 的类型是 double（其声明类型）
decltype((a->x)) z = y; // z 的类型是 const double&（左值表达式）
 
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) // 返回类型依赖于模板形参
{                                     // C++14 开始可以推导返回类型
    return t+u;
}
 
int main() 
{
    int i = 33;
    decltype(i) j = i * 2;
 
    std::cout << "i = " << i << ", "
              << "j = " << j << '\n';
 
    auto f = [](int a, int b) -> int
    {
        return a * b;
    };
 
    decltype(f) g = f; // lambda 的类型是独有且无名的
    i = f(2, 2);
    j = g(3, 3);
 
    std::cout << "i = " << i << ", "
              << "j = " << j << '\n';
}
```

输出：

```c++
i = 33, j = 66
i = 4, j = 9
```
